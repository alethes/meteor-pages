{"version":3,"file":"/packages/webapp.js","sources":["webapp/webapp_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8B;;AAEA,2B;AACA,+B;AACA,2B;AACA,+B;AACA,6B;AACA,mC;;AAEA,qC;AACA,yC;AACA,+B;;AAEA,0C;AACA,kC;;AAEA,kC;AACA,mC;;AAEA,Y;AACA,qB;;AAEA,mC;;AAEA,8B;AACA,2B;;AAEA,+C;AACA,kB;;AAEA,uB;;AAEA,oE;AACA,sE;AACA,Y;AACA,6E;AACA,qE;AACA,E;AACA,0B;AACA,oE;AACA,+D;AACA,iB;AACA,iC;AACA,yB;;AAEA,4C;AACA,uB;AACA,K;;AAEA,yB;;AAEA,2B;AACA,sB;AACA,8B;AACA,2D;AACA,sB;AACA,K;AACA,W;AACA,E;;AAEA,mE;AACA,oB;AACA,+B;AACA,uB;AACA,E;;AAEA,wE;AACA,+D;AACA,E;AACA,gC;AACA,yE;AACA,yE;AACA,2B;AACA,wE;AACA,oE;AACA,oD;AACA,kB;AACA,gC;AACA,gE;AACA,sB;AACA,K;;AAEA,6B;AACA,W;AACA,mC;AACA,qB;AACA,0D;AACA,wB;AACA,O;AACA,O;AACA,G;AACA,E;;;AAGA,gC;AACA,uC;AACA,wB;AACA,4B;AACA,E;;AAEA,4C;AACA,yD;AACA,E;;AAEA,yB;AACA,E;AACA,iE;AACA,kE;AACA,+C;AACA,E;AACA,wE;AACA,+D;AACA,sE;AACA,kE;AACA,W;AACA,E;AACA,kD;AACA,uE;AACA,E;AACA,uE;AACA,iE;AACA,gE;AACA,E;AACA,6D;AACA,qD;AACA,E;AACA,8E;AACA,8E;AACA,8E;AACA,sB;AACA,E;AACA,uE;AACA,qE;AACA,8C;AACA,E;AACA,mE;AACA,W;;;AAGA,yC;AACA,iC;AACA,8B;AACA,oC;AACA,4C;AACA,qE;AACA,G;AACA,wB;AACA,E;;AAEA,kD;AACA,oD;AACA,U;AACA,sC;AACA,4B;AACA,4B;AACA,2B;AACA,I;AACA,E;;AAEA,qD;AACA,kD;;AAEA,2C;AACA,U;AACA,wD;AACA,iC;AACA,I;AACA,E;;AAEA,8E;AACA,gF;AACA,sD;AACA,4B;AACA,4C;AACA,+B;AACA,oD;AACA,mC;AACA,4B;AACA,a;AACA,uC;AACA,oE;AACA,6C;AACA,K;AACA,4B;AACA,E;AACA,+C;AACA,gC;AACA,E;;AAEA,+B;AACA,6B;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,gC;AACA,iB;;AAEA,wD;AACA,c;AACA,E;;;AAGA,sE;AACA,+D;AACA,E;AACA,mE;AACA,sE;AACA,E;AACA,oE;AACA,sD;AACA,oE;AACA,oE;AACA,6C;AACA,qD;AACA,E;AACA,4D;AACA,oE;AACA,oB;;AAEA,4B;AACA,8D;AACA,2C;AACA,8C;AACA,yE;AACA,I;;AAEA,+D;AACA,8C;AACA,wE;AACA,uB;AACA,8B;AACA,S;AACA,I;AACA,kE;AACA,8C;AACA,wE;AACA,uB;AACA,8B;AACA,S;AACA,I;AACA,mD;AACA,iC;AACA,0C;AACA,oB;;AAEA,+B;AACA,6D;AACA,uD;AACA,I;AACA,G;;;;AAIA,4E;AACA,wE;AACA,yE;AACA,6E;AACA,iC;AACA,gE;AACA,oE;AACA,sC;AACA,gF;AACA,kC;AACA,gD;AACA,sE;AACA,mD;AACA,mC;AACA,gC;AACA,yC;AACA,K;AACA,iE;AACA,E;;;AAGA,4C;AACA,8C;AACA,0B;AACA,gB;AACA,oB;AACA,2B;;AAEA,qE;AACA,+D;AACA,oE;AACA,qB;AACA,wE;AACA,6B;AACA,+C;;AAEA,kD;;AAEA,sE;AACA,mE;AACA,0D;AACA,gC;AACA,+C;AACA,mC;AACA,c;AACA,K;;AAEA,uC;AACA,mE;AACA,oC;AACA,O;AACA,G;AACA,sC;AACA,E;;AAEA,6D;AACA,iE;AACA,4E;AACA,8C;;AAEA,+B;AACA,uC;AACA,kD;AACA,I;;AAEA,wC;AACA,c;AACA,uC;AACA,sD;AACA,0B;AACA,kC;AACA,mC;AACA,yC;AACA,oB;AACA,iC;AACA,gC;AACA,c;AACA,W;AACA,U;AACA,2D;AACA,gF;AACA,iD;AACA,+D;AACA,qE;AACA,wC;AACA,O;AACA,yB;AACA,I;AACA,E;;AAEA,4E;AACA,wC;AACA,oE;AACA,wD;AACA,E;AACA,2C;AACA,wE;AACA,wD;;AAEA,gB;;AAEA,qD;AACA,qC;AACA,gF;AACA,oD;AACA,W;AACA,W;AACA,G;AACA,sD;AACA,O;AACA,4C;AACA,e;AACA,W;AACA,W;AACA,G;;AAEA,oC;AACA,wB;AACA,6D;AACA,O;AACA,iB;AACA,c;AACA,I;;AAEA,iD;AACA,iD;AACA,kD;AACA,mE;AACA,W;AACA,mD;AACA,yD;AACA,gD;AACA,W;AACA,G;;AAEA,sC;AACA,W;AACA,W;AACA,G;;AAEA,4E;AACA,2E;AACA,Y;;AAEA,mC;;AAEA,kE;AACA,8D;AACA,kC;AACA,I;AACA,6E;AACA,8E;AACA,kE;AACA,8E;AACA,0E;AACA,0E;AACA,gD;AACA,6B;AACA,mC;AACA,8B;;AAEA,0E;AACA,4E;AACA,4B;AACA,I;AACA,6E;AACA,0E;AACA,0B;AACA,gC;AACA,kE;AACA,qC;AACA,G;;AAEA,2B;AACA,2E;AACA,mC;AACA,6D;AACA,oC;AACA,qE;AACA,qE;AACA,4C;AACA,wD;AACA,K;AACA,G;;AAEA,qB;AACA,4B;AACA,c;AACA,U;AACA,gC;AACA,qB;AACA,2E;AACA,mC;AACA,sD;AACA,2B;AACA,kB;AACA,Q;AACA,oC;AACA,+D;AACA,2B;AACA,kB;AACA,Q;AACA,iB;AACA,G;AACA,E;;AAEA,2C;AACA,kE;AACA,gD;;AAEA,0E;AACA,yB;AACA,sC;AACA,iD;AACA,E;;AAEA,mC;AACA,2B;AACA,iD;;AAEA,4C;AACA,2D;AACA,I;;AAEA,sD;AACA,kC;AACA,uB;AACA,+D;AACA,8D;AACA,sE;AACA,+C;AACA,qD;AACA,sE;AACA,qD;AACA,oE;AACA,6D;;AAEA,4D;AACA,4D;;AAEA,kD;;AAEA,2C;AACA,0C;AACA,oD;AACA,kE;AACA,4D;AACA,wC;AACA,4C;AACA,8C;AACA,6B;AACA,c;;AAEA,iC;AACA,iF;AACA,2C;AACA,6E;AACA,mE;AACA,+B;AACA,gB;AACA,a;AACA,W;AACA,W;;AAEA,uB;AACA,6B;AACA,4E;AACA,2D;AACA,oE;AACA,U;;AAEA,8C;;AAEA,qE;AACA,mD;AACA,8D;AACA,2C;AACA,0B;AACA,sB;AACA,U;AACA,Q;;AAEA,W;AACA,sE;AACA,yD;AACA,oD;AACA,kD;AACA,W;;AAEA,8B;AACA,kD;AACA,mB;AACA,oE;AACA,wB;AACA,O;AACA,O;AACA,I;;AAEA,qD;AACA,2E;AACA,gF;AACA,4E;AACA,gF;AACA,iC;AACA,sB;AACA,iC;AACA,mE;AACA,+C;AACA,kD;AACA,8C;AACA,S;AACA,O;AACA,M;;AAEA,kC;AACA,kE;AACA,qC;AACA,sD;AACA,uC;AACA,6C;AACA,S;;AAEA,8C;AACA,+B;;AAEA,qD;AACA,uD;AACA,2C;AACA,kE;AACA,Q;AACA,O;AACA,I;;AAEA,yC;;AAEA,c;AACA,sB;;AAEA,iD;AACA,8B;;AAEA,wE;AACA,4C;AACA,qC;AACA,8B;;AAEA,6C;AACA,8C;AACA,oE;AACA,oD;AACA,gC;AACA,6E;AACA,+D;AACA,gF;AACA,4C;AACA,mF;AACA,6D;AACA,a;AACA,2E;AACA,a;AACA,4B;AACA,8B;AACA,qC;AACA,qB;AACA,Y;AACA,a;AACA,K;AACA,K;;AAEA,0E;AACA,6B;AACA,2B;;AAEA,0C;AACA,iD;AACA,qC;AACA,uB;AACA,wE;AACA,a;AACA,K;;AAEA,2E;AACA,kD;AACA,wC;AACA,iC;;AAEA,oC;AACA,+E;AACA,+E;AACA,mC;AACA,0C;AACA,6E;AACA,gB;AACA,a;AACA,K;AACA,gE;AACA,gC;AACA,K;;AAEA,qC;AACA,0B;AACA,oB;;AAEA,mB;AACA,iD;AACA,M;AACA,qB;AACA,sC;;AAEA,gD;;AAEA,wE;AACA,6E;AACA,gF;AACA,8D;AACA,0D;AACA,kC;AACA,8D;AACA,gB;AACA,uB;AACA,K;;AAEA,iD;AACA,wD;AACA,yC;AACA,6D;;AAEA,qE;AACA,mC;AACA,Y;AACA,+B;AACA,K;;AAEA,oB;AACA,S;AACA,qD;AACA,iB;AACA,gD;AACA,kC;AACA,gB;AACA,uB;AACA,K;;AAEA,gC;AACA,2B;AACA,c;AACA,qB;AACA,K;;AAEA,gE;AACA,+B;AACA,uB;AACA,c;AACA,K;;;AAGA,0C;AACA,gC;;AAEA,0E;AACA,+E;AACA,mC;AACA,8C;;AAEA,sE;AACA,gF;AACA,S;AACA,qE;;;AAGA,4E;AACA,0B;AACA,2D;AACA,wB;AACA,mE;AACA,4E;AACA,kB;AACA,sC;;AAEA,yD;AACA,kB;AACA,a;AACA,qE;AACA,qB;AACA,6D;AACA,0B;AACA,S;AACA,O;AACA,sB;;AAEA,uC;;AAEA,8C;AACA,mC;AACA,wF;AACA,sB;AACA,a;;AAEA,qB;AACA,qB;AACA,oB;AACA,M;;AAEA,iB;AACA,oB;AACA,2C;AACA,2C;AACA,2B;AACA,mB;AACA,wC;AACA,mC;AACA,M;AACA,+B;AACA,+B;AACA,qC;AACA,U;AACA,Y;AACA,M;AACA,2E;AACA,8E;AACA,6D;AACA,oC;AACA,K;;AAEA,2E;AACA,gF;AACA,2B;AACA,0B;AACA,8E;AACA,8D;AACA,mE;AACA,2E;AACA,8E;AACA,4C;AACA,8B;AACA,oE;AACA,sE;AACA,yB;AACA,2D;AACA,wE;AACA,sB;AACA,yB;AACA,yD;AACA,gC;AACA,2C;AACA,K;AACA,0C;;AAEA,+D;AACA,oD;AACA,mC;AACA,oC;AACA,6E;AACA,wC;AACA,0D;AACA,uB;;AAEA,qE;AACA,yB;AACA,8B;AACA,mD;AACA,sE;AACA,+E;AACA,uD;AACA,oD;AACA,oB;AACA,mB;AACA,qC;AACA,8D;AACA,8B;AACA,wE;AACA,wE;AACA,4C;AACA,0C;AACA,2D;AACA,2D;AACA,yC;AACA,8C;AACA,4C;AACA,mB;AACA,+B;AACA,sD;AACA,mD;AACA,sC;AACA,oB;AACA,wB;AACA,kD;AACA,iB;AACA,uD;AACA,kC;AACA,sD;AACA,6C;AACA,+B;AACA,e;AACA,a;AACA,Y;AACA,S;AACA,S;;AAEA,2C;AACA,kC;AACA,+C;;AAEA,qB;AACA,2C;AACA,kC;AACA,Q;;AAEA,2B;AACA,sB;AACA,K;AACA,oB;AACA,yC;AACA,K;AACA,oB;AACA,I;AACA,E;;;AAGA,U;AACA,sD;AACA,kD;AACA,sD;AACA,wD;AACA,yC;AACA,iC;AACA,6C;AACA,4B;AACA,wC;AACA,8B;AACA,2C;AACA,8B;AACA,2C;AACA,8B;AACA,2C;;AAEA,uC;AACA,mE;AACA,a;AACA,gC;AACA,2C;AACA,+B;AACA,I;AACA,6B;;AAEA,uC;;AAEA,kE;AACA,sB;AACA,c;AACA,qE;AACA,oE;AACA,oE;AACA,sE;AACA,kE;AACA,qE;AACA,gE;AACA,2C;AACA,qB;AACA,oC;AACA,O;AACA,U;AACA,0D;AACA,kC;AACA,sB;AACA,O;AACA,M;AACA,G;;AAEA,gC;AACA,oC;AACA,qC;;AAEA,sB;AACA,yB;AACA,mC;AACA,oC;AACA,6B;AACA,I;AACA,kC;AACA,kB;AACA,2B;AACA,c;AACA,kB;AACA,oB;AACA,sB;AACA,M;AACA,I;;AAEA,iE;AACA,oC;AACA,oD;AACA,yD;AACA,oD;;AAEA,6D;AACA,kE;AACA,sE;AACA,oE;AACA,iE;AACA,kE;AACA,iE;AACA,kE;AACA,sE;AACA,a;;AAEA,8D;AACA,mE;AACA,kE;AACA,oE;AACA,mE;AACA,yB;;AAEA,mC;AACA,sE;AACA,0E;AACA,iE;AACA,iC;AACA,0B;AACA,0B;AACA,+B;AACA,gD;AACA,+B;AACA,gC;AACA,oD;AACA,wB;AACA,iE;AACA,O;AACA,K;AACA,qB;;AAEA,mE;AACA,kD;;;AAGA,0C;AACA,kC;AACA,oE;AACA,sE;AACA,oE;AACA,sE;AACA,gC;AACA,wC;AACA,0C;;AAEA,oD;AACA,sC;AACA,4B;AACA,4B;AACA,6C;AACA,Y;AACA,iE;AACA,2D;AACA,2C;AACA,0C;AACA,wD;AACA,sD;AACA,K;;AAEA,oB;AACA,6B;AACA,iB;AACA,iB;AACA,yB;AACA,oC;AACA,U;AACA,kB;AACA,0B;AACA,4B;AACA,4B;AACA,sD;AACA,U;AACA,qC;AACA,yB;AACA,K;;AAEA,qB;AACA,8B;AACA,iB;AACA,iB;AACA,mC;AACA,6B;AACA,wC;AACA,U;AACA,kB;AACA,0B;AACA,4B;AACA,4B;AACA,uC;AACA,U;AACA,sC;AACA,yB;;AAEA,iE;AACA,oE;AACA,yD;AACA,4C;AACA,gC;AACA,mB;AACA,mB;AACA,qC;AACA,6B;AACA,2C;AACA,qB;AACA,Y;AACA,oB;AACA,4B;AACA,8B;AACA,8B;AACA,yC;AACA,Y;AACA,wC;AACA,2B;AACA,O;AACA,K;AACA,K;;AAEA,oB;AACA,kB;AACA,E;;AAEA,yD;AACA,E;AACA,kE;AACA,2C;AACA,E;AACA,sE;AACA,mE;AACA,oE;AACA,gE;AACA,gC;AACA,E;AACA,mB;AACA,8C;AACA,2B;AACA,6D;AACA,yD;AACA,a;AACA,8D;AACA,qD;AACA,Y;AACA,mE;AACA,iE;AACA,a;AACA,E;AACA,qE;AACA,E;AACA,iE;AACA,mE;AACA,oE;AACA,E;AACA,sE;AACA,sE;AACA,qE;AACA,kE;AACA,S;AACA,E;AACA,qE;AACA,sE;AACA,kE;AACA,uD;AACA,kE;AACA,oE;AACA,sC;AACA,E;AACA,sE;AACA,0D;AACA,sE;AACA,+B;AACA,E;AACA,mE;AACA,mE;AACA,iE;AACA,Q;AACA,E;AACA,kB;AACA,kE;AACA,oE;AACA,gB;AACA,4D;AACA,kE;AACA,sE;AACA,qE;AACA,iE;AACA,iB;AACA,gB;AACA,oD;AACA,sB;AACA,c;AACA,c;AACA,oB;;AAEA,Y;AACA,2C;AACA,8C;;AAEA,+C;AACA,E;;AAEA,sC;AACA,6B;;AAEA,kB;;;AAGA,gC;;AAEA,oD;AACA,8B;AACA,E;;AAEA,4D;AACA,+B;AACA,wC;AACA,E;;AAEA,2D;AACA,8B;AACA,wC;AACA,E;;AAEA,oE;AACA,wE;AACA,qE;AACA,sC;AACA,4B;AACA,mD;AACA,8D;AACA,E;;AAEA,qB;AACA,gD;AACA,wD;AACA,oC","sourcesContent":["////////// Requires //////////\n\nvar fs = Npm.require(\"fs\");\nvar http = Npm.require(\"http\");\nvar os = Npm.require(\"os\");\nvar path = Npm.require(\"path\");\nvar url = Npm.require(\"url\");\nvar crypto = Npm.require(\"crypto\");\n\nvar connect = Npm.require('connect');\nvar useragent = Npm.require('useragent');\nvar send = Npm.require('send');\n\nvar Future = Npm.require('fibers/future');\nvar Fiber = Npm.require('fibers');\n\nvar SHORT_SOCKET_TIMEOUT = 5*1000;\nvar LONG_SOCKET_TIMEOUT = 120*1000;\n\nWebApp = {};\nWebAppInternals = {};\n\nWebApp.defaultArch = 'web.browser';\n\n// XXX maps archs to manifests\nWebApp.clientPrograms = {};\n\n// XXX maps archs to program path on filesystem\nvar archPath = {};\n\nvar bundledJsCssPrefix;\n\n// Keepalives so that when the outer server dies unceremoniously and\n// doesn't kill us, we quit ourselves. A little gross, but better than\n// pidfiles.\n// XXX This should really be part of the boot script, not the webapp package.\n//     Or we should just get rid of it, and rely on containerization.\n//\n// XXX COMPAT WITH 0.9.2.2\n// Keepalives have been replaced with a check that the parent pid is\n// still running. We keep the --keep-alive option for backwards\n// compatibility.\nvar initKeepalive = function () {\n  var keepaliveCount = 0;\n\n  process.stdin.on('data', function (data) {\n    keepaliveCount = 0;\n  });\n\n  process.stdin.resume();\n\n  setInterval(function () {\n    keepaliveCount ++;\n    if (keepaliveCount >= 3) {\n      console.log(\"Failed to receive keepalive! Exiting.\");\n      process.exit(1);\n    }\n  }, 3000);\n};\n\n// Check that we have a pid that looks like an integer (non-decimal\n// integer is okay).\nvar validPid = function (pid) {\n  return ! isNaN(+pid);\n};\n\n// As a replacement to the old keepalives mechanism, check for a running\n// parent every few seconds. Exit if the parent is not running.\n//\n// Two caveats to this strategy:\n// * Doesn't catch the case where the parent is CPU-hogging (but maybe we\n//   don't want to catch that case anyway, since the bundler not yielding\n//   is what caused #2536).\n// * Could be fooled by pid re-use, i.e. if another process comes up and\n//   takes the parent process's place before the child process dies.\nvar startCheckForLiveParent = function (parentPid) {\n  if (parentPid) {\n    if (! validPid(parentPid)) {\n      console.error(\"--parent-pid must be a valid process ID.\");\n      process.exit(1);\n    }\n\n    setInterval(function () {\n      try {\n        process.kill(parentPid, 0);\n      } catch (err) {\n        console.error(\"Parent process is dead! Exiting.\");\n        process.exit(1);\n      }\n    });\n  }\n};\n\n\nvar sha1 = function (contents) {\n  var hash = crypto.createHash('sha1');\n  hash.update(contents);\n  return hash.digest('hex');\n};\n\nvar readUtf8FileSync = function (filename) {\n  return Meteor.wrapAsync(fs.readFile)(filename, 'utf8');\n};\n\n// #BrowserIdentification\n//\n// We have multiple places that want to identify the browser: the\n// unsupported browser page, the appcache package, and, eventually\n// delivering browser polyfills only as needed.\n//\n// To avoid detecting the browser in multiple places ad-hoc, we create a\n// Meteor \"browser\" object. It uses but does not expose the npm\n// useragent module (we could choose a different mechanism to identify\n// the browser in the future if we wanted to).  The browser object\n// contains\n//\n// * `name`: the name of the browser in camel case\n// * `major`, `minor`, `patch`: integers describing the browser version\n//\n// Also here is an early version of a Meteor `request` object, intended\n// to be a high-level description of the request without exposing\n// details of connect's low-level `req`.  Currently it contains:\n//\n// * `browser`: browser identification object described above\n// * `url`: parsed url, including parsed query params\n//\n// As a temporary hack there is a `categorizeRequest` function on WebApp which\n// converts a connect `req` to a Meteor `request`. This can go away once smart\n// packages such as appcache are being passed a `request` object directly when\n// they serve content.\n//\n// This allows `request` to be used uniformly: it is passed to the html\n// attributes hook, and the appcache package can use it when deciding\n// whether to generate a 404 for the manifest.\n//\n// Real routing / server side rendering will probably refactor this\n// heavily.\n\n\n// e.g. \"Mobile Safari\" => \"mobileSafari\"\nvar camelCase = function (name) {\n  var parts = name.split(' ');\n  parts[0] = parts[0].toLowerCase();\n  for (var i = 1;  i < parts.length;  ++i) {\n    parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].substr(1);\n  }\n  return parts.join('');\n};\n\nvar identifyBrowser = function (userAgentString) {\n  var userAgent = useragent.lookup(userAgentString);\n  return {\n    name: camelCase(userAgent.family),\n    major: +userAgent.major,\n    minor: +userAgent.minor,\n    patch: +userAgent.patch\n  };\n};\n\n// XXX Refactor as part of implementing real routing.\nWebAppInternals.identifyBrowser = identifyBrowser;\n\nWebApp.categorizeRequest = function (req) {\n  return {\n    browser: identifyBrowser(req.headers['user-agent']),\n    url: url.parse(req.url, true)\n  };\n};\n\n// HTML attribute hooks: functions to be called to determine any attributes to\n// be added to the '<html>' tag. Each function is passed a 'request' object (see\n// #BrowserIdentification) and should return a string,\nvar htmlAttributeHooks = [];\nvar getHtmlAttributes = function (request) {\n  var combinedAttributes  = {};\n  _.each(htmlAttributeHooks || [], function (hook) {\n    var attributes = hook(request);\n    if (attributes === null)\n      return;\n    if (typeof attributes !== 'object')\n      throw Error(\"HTML attribute hook must return null or object\");\n    _.extend(combinedAttributes, attributes);\n  });\n  return combinedAttributes;\n};\nWebApp.addHtmlAttributeHook = function (hook) {\n  htmlAttributeHooks.push(hook);\n};\n\n// Serve app HTML for this URL?\nvar appUrl = function (url) {\n  if (url === '/favicon.ico' || url === '/robots.txt')\n    return false;\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file name we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if (url === '/app.manifest')\n    return false;\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  if (RoutePolicy.classify(url))\n    return false;\n\n  // we currently return app HTML on all URLs by default\n  return true;\n};\n\n\n// We need to calculate the client hash after all packages have loaded\n// to give them a chance to populate __meteor_runtime_config__.\n//\n// Calculating the hash during startup means that packages can only\n// populate __meteor_runtime_config__ during load, not during startup.\n//\n// Calculating instead it at the beginning of main after all startup\n// hooks had run would allow packages to also populate\n// __meteor_runtime_config__ during startup, but that's too late for\n// autoupdate because it needs to have the client hash at startup to\n// insert the auto update version itself into\n// __meteor_runtime_config__ to get it to the client.\n//\n// An alternative would be to give autoupdate a \"post-start,\n// pre-listen\" hook to allow it to insert the auto update version at\n// the right moment.\n\nMeteor.startup(function () {\n  var calculateClientHash = WebAppHashing.calculateClientHash;\n  WebApp.clientHash = function (archName) {\n    archName = archName || WebApp.defaultArch;\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest);\n  };\n\n  WebApp.calculateClientHashRefreshable = function (archName) {\n    archName = archName || WebApp.defaultArch;\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest,\n      function (name) {\n        return name === \"css\";\n      });\n  };\n  WebApp.calculateClientHashNonRefreshable = function (archName) {\n    archName = archName || WebApp.defaultArch;\n    return calculateClientHash(WebApp.clientPrograms[archName].manifest,\n      function (name) {\n        return name !== \"css\";\n      });\n  };\n  WebApp.calculateClientHashCordova = function () {\n    var archName = 'web.cordova';\n    if (! WebApp.clientPrograms[archName])\n      return 'none';\n\n    return calculateClientHash(\n      WebApp.clientPrograms[archName].manifest, null, _.pick(\n        __meteor_runtime_config__, 'PUBLIC_SETTINGS'));\n  };\n});\n\n\n\n// When we have a request pending, we want the socket timeout to be long, to\n// give ourselves a while to serve it, and to allow sockjs long polls to\n// complete.  On the other hand, we want to close idle sockets relatively\n// quickly, so that we can shut down relatively promptly but cleanly, without\n// cutting off anyone's response.\nWebApp._timeoutAdjustmentRequestCallback = function (req, res) {\n  // this is really just req.socket.setTimeout(LONG_SOCKET_TIMEOUT);\n  req.setTimeout(LONG_SOCKET_TIMEOUT);\n  // Insert our new finish listener to run BEFORE the existing one which removes\n  // the response from the socket.\n  var finishListeners = res.listeners('finish');\n  // XXX Apparently in Node 0.12 this event is now called 'prefinish'.\n  // https://github.com/joyent/node/commit/7c9b6070\n  res.removeAllListeners('finish');\n  res.on('finish', function () {\n    res.setTimeout(SHORT_SOCKET_TIMEOUT);\n  });\n  _.each(finishListeners, function (l) { res.on('finish', l); });\n};\n\n\n// Will be updated by main before we listen.\n// Map from client arch to boilerplate object.\n// Boilerplate object has:\n//   - func: XXX\n//   - baseData: XXX\nvar boilerplateByArch = {};\n\n// Given a request (as returned from `categorizeRequest`), return the\n// boilerplate HTML to serve for that request. Memoizes on HTML\n// attributes (used by, eg, appcache) and whether inline scripts are\n// currently allowed.\n// XXX so far this function is always called with arch === 'web.browser'\nvar memoizedBoilerplate = {};\nvar getBoilerplate = function (request, arch) {\n\n  var htmlAttributes = getHtmlAttributes(request);\n\n  // The only thing that changes from request to request (for now) are\n  // the HTML attributes (used by, eg, appcache) and whether inline\n  // scripts are allowed, so we can memoize based on that.\n  var memHash = JSON.stringify({\n    inlineScriptsAllowed: inlineScriptsAllowed,\n    htmlAttributes: htmlAttributes,\n    arch: arch\n  });\n\n  if (! memoizedBoilerplate[memHash]) {\n    memoizedBoilerplate[memHash] = boilerplateByArch[arch].toHTML({\n      htmlAttributes: htmlAttributes\n    });\n  }\n  return memoizedBoilerplate[memHash];\n};\n\nWebAppInternals.generateBoilerplateInstance = function (arch,\n                                                        manifest,\n                                                        additionalOptions) {\n  additionalOptions = additionalOptions || {};\n\n  var runtimeConfig = _.extend(\n    _.clone(__meteor_runtime_config__),\n    additionalOptions.runtimeConfigOverrides || {}\n  );\n\n  return new Boilerplate(arch, manifest,\n    _.extend({\n      pathMapper: function (itemPath) {\n        return path.join(archPath[arch], itemPath); },\n      baseDataExtension: {\n        additionalStaticJs: _.map(\n          additionalStaticJs || [],\n          function (contents, pathname) {\n            return {\n              pathname: pathname,\n              contents: contents\n            };\n          }\n        ),\n        meteorRuntimeConfig: JSON.stringify(runtimeConfig),\n        rootUrlPathPrefix: __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '',\n        bundledJsCssPrefix: bundledJsCssPrefix ||\n          __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '',\n        inlineScriptsAllowed: WebAppInternals.inlineScriptsAllowed(),\n        inline: additionalOptions.inline\n      }\n    }, additionalOptions)\n  );\n};\n\n// A mapping from url path to \"info\". Where \"info\" has the following fields:\n// - type: the type of file to be served\n// - cacheable: optionally, whether the file should be cached or not\n// - sourceMapUrl: optionally, the url of the source map\n//\n// Info also contains one of the following:\n// - content: the stringified content that should be served at this path\n// - absolutePath: the absolute path on disk to the file\n\nvar staticFiles;\n\n// Serve static files from the manifest or added with\n// `addStaticJs`. Exported for tests.\nWebAppInternals.staticFilesMiddleware = function (staticFiles, req, res, next) {\n  if ('GET' != req.method && 'HEAD' != req.method) {\n    next();\n    return;\n  }\n  var pathname = connect.utils.parseUrl(req).pathname;\n  try {\n    pathname = decodeURIComponent(pathname);\n  } catch (e) {\n    next();\n    return;\n  }\n\n  var serveStaticJs = function (s) {\n    res.writeHead(200, {\n      'Content-type': 'application/javascript; charset=UTF-8'\n    });\n    res.write(s);\n    res.end();\n  };\n\n  if (pathname === \"/meteor_runtime_config.js\" &&\n      ! WebAppInternals.inlineScriptsAllowed()) {\n    serveStaticJs(\"__meteor_runtime_config__ = \" +\n                  JSON.stringify(__meteor_runtime_config__) + \";\");\n    return;\n  } else if (_.has(additionalStaticJs, pathname) &&\n              ! WebAppInternals.inlineScriptsAllowed()) {\n    serveStaticJs(additionalStaticJs[pathname]);\n    return;\n  }\n\n  if (!_.has(staticFiles, pathname)) {\n    next();\n    return;\n  }\n\n  // We don't need to call pause because, unlike 'static', once we call into\n  // 'send' and yield to the event loop, we never call another handler with\n  // 'next'.\n\n  var info = staticFiles[pathname];\n\n  // Cacheable files are files that should never change. Typically\n  // named by their hash (eg meteor bundled js and css files).\n  // We cache them ~forever (1yr).\n  //\n  // We cache non-cacheable files anyway. This isn't really correct, as users\n  // can change the files and changes won't propagate immediately. However, if\n  // we don't cache them, browsers will 'flicker' when rerendering\n  // images. Eventually we will probably want to rewrite URLs of static assets\n  // to include a query parameter to bust caches. That way we can both get\n  // good caching behavior and allow users to change assets without delay.\n  // https://github.com/meteor/meteor/issues/773\n  var maxAge = info.cacheable\n        ? 1000 * 60 * 60 * 24 * 365\n        : 1000 * 60 * 60 * 24;\n\n  // Set the X-SourceMap header, which current Chrome, FireFox, and Safari\n  // understand.  (The SourceMap header is slightly more spec-correct but FF\n  // doesn't understand it.)\n  //\n  // You may also need to enable source maps in Chrome: open dev tools, click\n  // the gear in the bottom right corner, and select \"enable source maps\".\n  if (info.sourceMapUrl) {\n    res.setHeader('X-SourceMap',\n                  __meteor_runtime_config__.ROOT_URL_PATH_PREFIX +\n                  info.sourceMapUrl);\n  }\n\n  if (info.type === \"js\") {\n    res.setHeader(\"Content-Type\", \"application/javascript; charset=UTF-8\");\n  } else if (info.type === \"css\") {\n    res.setHeader(\"Content-Type\", \"text/css; charset=UTF-8\");\n  } else if (info.type === \"json\") {\n    res.setHeader(\"Content-Type\", \"application/json; charset=UTF-8\");\n    // XXX if it is a manifest we are serving, set additional headers\n    if (/\\/manifest.json$/.test(pathname)) {\n      res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    }\n  }\n\n  if (info.content) {\n    res.write(info.content);\n    res.end();\n  } else {\n    send(req, info.absolutePath)\n      .maxage(maxAge)\n      .hidden(true)  // if we specified a dotfile in the manifest, serve it\n      .on('error', function (err) {\n        Log.error(\"Error serving static file \" + err);\n        res.writeHead(500);\n        res.end();\n      })\n      .on('directory', function () {\n        Log.error(\"Unexpected directory \" + info.absolutePath);\n        res.writeHead(500);\n        res.end();\n      })\n      .pipe(res);\n  }\n};\n\nvar getUrlPrefixForArch = function (arch) {\n  // XXX we rely on the fact that arch names don't contain slashes\n  // in that case we would need to uri escape it\n\n  // We add '__' to the beginning of non-standard archs to \"scope\" the url\n  // to Meteor internals.\n  return arch === WebApp.defaultArch ?\n    '' : '/' + '__' + arch.replace(/^web\\./, '');\n};\n\nvar runWebAppServer = function () {\n  var shuttingDown = false;\n  var syncQueue = new Meteor._SynchronousQueue();\n\n  var getItemPathname = function (itemUrl) {\n    return decodeURIComponent(url.parse(itemUrl).pathname);\n  };\n\n  WebAppInternals.reloadClientPrograms = function () {\n    syncQueue.runTask(function() {\n      staticFiles = {};\n      var generateClientProgram = function (clientPath, arch) {\n        // read the control for the client we'll be serving up\n        var clientJsonPath = path.join(__meteor_bootstrap__.serverDir,\n                                   clientPath);\n        var clientDir = path.dirname(clientJsonPath);\n        var clientJson = JSON.parse(readUtf8FileSync(clientJsonPath));\n        if (clientJson.format !== \"web-program-pre1\")\n          throw new Error(\"Unsupported format for client assets: \" +\n                          JSON.stringify(clientJson.format));\n\n        if (! clientJsonPath || ! clientDir || ! clientJson)\n          throw new Error(\"Client config file not parsed.\");\n\n        var urlPrefix = getUrlPrefixForArch(arch);\n\n        var manifest = clientJson.manifest;\n        _.each(manifest, function (item) {\n          if (item.url && item.where === \"client\") {\n            staticFiles[urlPrefix + getItemPathname(item.url)] = {\n              absolutePath: path.join(clientDir, item.path),\n              cacheable: item.cacheable,\n              // Link from source to its map\n              sourceMapUrl: item.sourceMapUrl,\n              type: item.type\n            };\n\n            if (item.sourceMap) {\n              // Serve the source map too, under the specified URL. We assume all\n              // source maps are cacheable.\n              staticFiles[urlPrefix + getItemPathname(item.sourceMapUrl)] = {\n                absolutePath: path.join(clientDir, item.sourceMap),\n                cacheable: true\n              };\n            }\n          }\n        });\n\n        var program = {\n          manifest: manifest,\n          version: WebAppHashing.calculateClientHash(manifest, null, _.pick(\n            __meteor_runtime_config__, 'PUBLIC_SETTINGS')),\n          PUBLIC_SETTINGS: __meteor_runtime_config__.PUBLIC_SETTINGS\n        };\n\n        WebApp.clientPrograms[arch] = program;\n\n        // Serve the program as a string at /foo/<arch>/manifest.json\n        // XXX change manifest.json -> program.json\n        staticFiles[path.join(urlPrefix, 'manifest.json')] = {\n          content: JSON.stringify(program),\n          cacheable: true,\n          type: \"json\"\n        };\n      };\n\n      try {\n        var clientPaths = __meteor_bootstrap__.configJson.clientPaths;\n        _.each(clientPaths, function (clientPath, arch) {\n          archPath[arch] = path.dirname(clientPath);\n          generateClientProgram(clientPath, arch);\n        });\n\n        // Exported for tests.\n        WebAppInternals.staticFiles = staticFiles;\n      } catch (e) {\n        Log.error(\"Error reloading the client program: \" + e.stack);\n        process.exit(1);\n      }\n    });\n  };\n\n  WebAppInternals.generateBoilerplate = function () {\n    // This boilerplate will be served to the mobile devices when used with\n    // Meteor/Cordova for the Hot-Code Push and since the file will be served by\n    // the device's server, it is important to set the DDP url to the actual\n    // Meteor server accepting DDP connections and not the device's file server.\n    var defaultOptionsForArch = {\n      'web.cordova': {\n        runtimeConfigOverrides: {\n          DDP_DEFAULT_CONNECTION_URL: process.env.MOBILE_DDP_URL ||\n            __meteor_runtime_config__.ROOT_URL,\n          ROOT_URL: process.env.MOBILE_ROOT_URL ||\n            __meteor_runtime_config__.ROOT_URL\n        }\n      }\n    };\n\n    syncQueue.runTask(function() {\n      _.each(WebApp.clientPrograms, function (program, archName) {\n        boilerplateByArch[archName] =\n          WebAppInternals.generateBoilerplateInstance(\n            archName, program.manifest,\n            defaultOptionsForArch[archName]);\n      });\n\n      // Clear the memoized boilerplate cache.\n      memoizedBoilerplate = {};\n\n      // Configure CSS injection for the default arch\n      // XXX implement the CSS injection for all archs?\n      WebAppInternals.refreshableAssets = {\n        allCss: boilerplateByArch[WebApp.defaultArch].baseData.css\n      };\n    });\n  };\n\n  WebAppInternals.reloadClientPrograms();\n\n  // webserver\n  var app = connect();\n\n  // Auto-compress any json, javascript, or text.\n  app.use(connect.compress());\n\n  // Packages and apps can add handlers that run before any other Meteor\n  // handlers via WebApp.rawConnectHandlers.\n  var rawConnectHandlers = connect();\n  app.use(rawConnectHandlers);\n\n  // Strip off the path prefix, if it exists.\n  app.use(function (request, response, next) {\n    var pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n    var url = Npm.require('url').parse(request.url);\n    var pathname = url.pathname;\n    // check if the path in the url starts with the path prefix (and the part\n    // after the path prefix must start with a / if it exists.)\n    if (pathPrefix && pathname.substring(0, pathPrefix.length) === pathPrefix &&\n       (pathname.length == pathPrefix.length\n        || pathname.substring(pathPrefix.length, pathPrefix.length + 1) === \"/\")) {\n      request.url = request.url.substring(pathPrefix.length);\n      next();\n    } else if (pathname === \"/favicon.ico\" || pathname === \"/robots.txt\") {\n      next();\n    } else if (pathPrefix) {\n      response.writeHead(404);\n      response.write(\"Unknown path\");\n      response.end();\n    } else {\n      next();\n    }\n  });\n\n  // Parse the query string into res.query. Used by oauth_server, but it's\n  // generally pretty handy..\n  app.use(connect.query());\n\n  // Serve static files from the manifest.\n  // This is inspired by the 'static' middleware.\n  app.use(function (req, res, next) {\n    Fiber(function () {\n     WebAppInternals.staticFilesMiddleware(staticFiles, req, res, next);\n    }).run();\n  });\n\n  // Packages and apps can add handlers to this via WebApp.connectHandlers.\n  // They are inserted before our default handler.\n  var packageAndAppHandlers = connect();\n  app.use(packageAndAppHandlers);\n\n  var suppressConnectErrors = false;\n  // connect knows it is an error handler because it has 4 arguments instead of\n  // 3. go figure.  (It is not smart enough to find such a thing if it's hidden\n  // inside packageAndAppHandlers.)\n  app.use(function (err, req, res, next) {\n    if (!err || !suppressConnectErrors || !req.headers['x-suppress-error']) {\n      next(err);\n      return;\n    }\n    res.writeHead(err.status, { 'Content-Type': 'text/plain' });\n    res.end(\"An error message\");\n  });\n\n  app.use(function (req, res, next) {\n    if (! appUrl(req.url))\n      return next();\n\n    var headers = {\n      'Content-Type':  'text/html; charset=utf-8'\n    };\n    if (shuttingDown)\n      headers['Connection'] = 'Close';\n\n    var request = WebApp.categorizeRequest(req);\n\n    if (request.url.query && request.url.query['meteor_css_resource']) {\n      // In this case, we're requesting a CSS resource in the meteor-specific\n      // way, but we don't have it.  Serve a static css file that indicates that\n      // we didn't have it, so we can detect that and refresh.\n      headers['Content-Type'] = 'text/css; charset=utf-8';\n      res.writeHead(200, headers);\n      res.write(\".meteor-css-not-found-error { width: 0px;}\");\n      res.end();\n      return undefined;\n    }\n\n    // /packages/asdfsad ... /__cordova/dafsdf.js\n    var pathname = connect.utils.parseUrl(req).pathname;\n    var archKey = pathname.split('/')[1];\n    var archKeyCleaned = 'web.' + archKey.replace(/^__/, '');\n\n    if (! /^__/.test(archKey) || ! _.has(archPath, archKeyCleaned)) {\n      archKey = WebApp.defaultArch;\n    } else {\n      archKey = archKeyCleaned;\n    }\n\n    var boilerplate;\n    try {\n      boilerplate = getBoilerplate(request, archKey);\n    } catch (e) {\n      Log.error(\"Error running template: \" + e);\n      res.writeHead(500, headers);\n      res.end();\n      return undefined;\n    }\n\n    res.writeHead(200, headers);\n    res.write(boilerplate);\n    res.end();\n    return undefined;\n  });\n\n  // Return 404 by default, if no other handlers serve this URL.\n  app.use(function (req, res) {\n    res.writeHead(404);\n    res.end();\n  });\n\n\n  var httpServer = http.createServer(app);\n  var onListeningCallbacks = [];\n\n  // After 5 seconds w/o data on a socket, kill it.  On the other hand, if\n  // there's an outstanding request, give it a higher timeout instead (to avoid\n  // killing long-polling requests)\n  httpServer.setTimeout(SHORT_SOCKET_TIMEOUT);\n\n  // Do this here, and then also in livedata/stream_server.js, because\n  // stream_server.js kills all the current request handlers when installing its\n  // own.\n  httpServer.on('request', WebApp._timeoutAdjustmentRequestCallback);\n\n\n  // For now, handle SIGHUP here.  Later, this should be in some centralized\n  // Meteor shutdown code.\n  process.on('SIGHUP', Meteor.bindEnvironment(function () {\n    shuttingDown = true;\n    // tell others with websockets open that we plan to close this.\n    // XXX: Eventually, this should be done with a standard meteor shut-down\n    // logic path.\n    httpServer.emit('meteor-closing');\n\n    httpServer.close(Meteor.bindEnvironment(function () {\n      if (proxy) {\n        try {\n          proxy.call('removeBindingsForJob', process.env.GALAXY_JOB);\n        } catch (e) {\n          Log.error(\"Error removing bindings: \" + e.message);\n          process.exit(1);\n        }\n      }\n      process.exit(0);\n\n    }, \"On http server close failed\"));\n\n    // Ideally we will close before this hits.\n    Meteor.setTimeout(function () {\n      Log.warn(\"Closed by SIGHUP but one or more HTTP requests may not have finished.\");\n      process.exit(1);\n    }, 5000);\n\n  }, function (err) {\n    console.log(err);\n    process.exit(1);\n  }));\n\n  // start up app\n  _.extend(WebApp, {\n    connectHandlers: packageAndAppHandlers,\n    rawConnectHandlers: rawConnectHandlers,\n    httpServer: httpServer,\n    // For testing.\n    suppressConnectErrors: function () {\n      suppressConnectErrors = true;\n    },\n    onListening: function (f) {\n      if (onListeningCallbacks)\n        onListeningCallbacks.push(f);\n      else\n        f();\n    },\n    // Hack: allow http tests to call connect.basicAuth without making them\n    // Npm.depends on another copy of connect. (That would be fine if we could\n    // have test-only NPM dependencies but is overkill here.)\n    __basicAuth__: connect.basicAuth\n  });\n\n  // Let the rest of the packages (and Meteor.startup hooks) insert connect\n  // middlewares and update __meteor_runtime_config__, then keep going to set up\n  // actually serving HTML.\n  main = function (argv) {\n    // main happens post startup hooks, so we don't need a Meteor.startup() to\n    // ensure this happens after the galaxy package is loaded.\n    var AppConfig = Package[\"application-configuration\"].AppConfig;\n    // We used to use the optimist npm package to parse argv here, but it's\n    // overkill (and no longer in the dev bundle). Just assume any instance of\n    // '--keepalive' is a use of the option.\n    // XXX COMPAT WITH 0.9.2.2\n    // We used to expect keepalives to be written to stdin every few\n    // seconds; now we just check if the parent process is still alive\n    // every few seconds.\n    var expectKeepalives = _.contains(argv, '--keepalive');\n    // XXX Saddest argument parsing ever, should we add optimist back to\n    // the dev bundle?\n    var parentPid = null;\n    var parentPidIndex = _.indexOf(argv, \"--parent-pid\");\n    if (parentPidIndex !== -1) {\n      parentPid = argv[parentPidIndex + 1];\n    }\n    WebAppInternals.generateBoilerplate();\n\n    // only start listening after all the startup code has run.\n    var localPort = parseInt(process.env.PORT) || 0;\n    var host = process.env.BIND_IP;\n    var localIp = host || '0.0.0.0';\n    httpServer.listen(localPort, localIp, Meteor.bindEnvironment(function() {\n      if (expectKeepalives || parentPid)\n        console.log(\"LISTENING\"); // must match run-app.js\n      var proxyBinding;\n\n      AppConfig.configurePackage('webapp', function (configuration) {\n        if (proxyBinding)\n          proxyBinding.stop();\n        if (configuration && configuration.proxy) {\n          // TODO: We got rid of the place where this checks the app's\n          // configuration, because this wants to be configured for some things\n          // on a per-job basis.  Discuss w/ teammates.\n          proxyBinding = AppConfig.configureService(\n            \"proxy\",\n            \"pre0\",\n            function (proxyService) {\n              if (proxyService && ! _.isEmpty(proxyService)) {\n                var proxyConf;\n                // XXX Figure out a per-job way to specify bind location\n                // (besides hardcoding the location for ADMIN_APP jobs).\n                if (process.env.ADMIN_APP) {\n                  var bindPathPrefix = \"\";\n                  if (process.env.GALAXY_APP !== \"panel\") {\n                    bindPathPrefix = \"/\" + bindPathPrefix +\n                      encodeURIComponent(\n                        process.env.GALAXY_APP\n                      ).replace(/\\./g, '_');\n                  }\n                  proxyConf = {\n                    bindHost: process.env.GALAXY_NAME,\n                    bindPathPrefix: bindPathPrefix,\n                    requiresAuth: true\n                  };\n                } else {\n                  proxyConf = configuration.proxy;\n                }\n                Log(\"Attempting to bind to proxy at \" +\n                    proxyService);\n                WebAppInternals.bindToProxy(_.extend({\n                  proxyEndpoint: proxyService\n                }, proxyConf));\n              }\n            }\n          );\n        }\n      });\n\n      var callbacks = onListeningCallbacks;\n      onListeningCallbacks = null;\n      _.each(callbacks, function (x) { x(); });\n\n    }, function (e) {\n      console.error(\"Error listening:\", e);\n      console.error(e && e.stack);\n    }));\n\n    if (expectKeepalives) {\n      initKeepalive();\n    }\n    if (parentPid) {\n      startCheckForLiveParent(parentPid);\n    }\n    return 'DAEMON';\n  };\n};\n\n\nvar proxy;\nWebAppInternals.bindToProxy = function (proxyConfig) {\n  var securePort = proxyConfig.securePort || 4433;\n  var insecurePort = proxyConfig.insecurePort || 8080;\n  var bindPathPrefix = proxyConfig.bindPathPrefix || \"\";\n  // XXX also support galaxy-based lookup\n  if (!proxyConfig.proxyEndpoint)\n    throw new Error(\"missing proxyEndpoint\");\n  if (!proxyConfig.bindHost)\n    throw new Error(\"missing bindHost\");\n  if (!process.env.GALAXY_JOB)\n    throw new Error(\"missing $GALAXY_JOB\");\n  if (!process.env.GALAXY_APP)\n    throw new Error(\"missing $GALAXY_APP\");\n  if (!process.env.LAST_START)\n    throw new Error(\"missing $LAST_START\");\n\n  // XXX rename pid argument to bindTo.\n  // XXX factor out into a 'getPid' function in a 'galaxy' package?\n  var pid = {\n    job: process.env.GALAXY_JOB,\n    lastStarted: +(process.env.LAST_START),\n    app: process.env.GALAXY_APP\n  };\n  var myHost = os.hostname();\n\n  WebAppInternals.usingDdpProxy = true;\n\n  // This is run after packages are loaded (in main) so we can use\n  // Follower.connect.\n  if (proxy) {\n    // XXX the concept here is that our configuration has changed and\n    // we have connected to an entirely new follower set, which does\n    // not have the state that we set up on the follower set that we\n    // were previously connected to, and so we need to recreate all of\n    // our bindings -- analogous to getting a SIGHUP and rereading\n    // your configuration file. so probably this should actually tear\n    // down the connection and make a whole new one, rather than\n    // hot-reconnecting to a different URL.\n    proxy.reconnect({\n      url: proxyConfig.proxyEndpoint\n    });\n  } else {\n    proxy = Package[\"follower-livedata\"].Follower.connect(\n      proxyConfig.proxyEndpoint, {\n        group: \"proxy\"\n      }\n    );\n  }\n\n  var route = process.env.ROUTE;\n  var ourHost = route.split(\":\")[0];\n  var ourPort = +route.split(\":\")[1];\n\n  var outstanding = 0;\n  var startedAll = false;\n  var checkComplete = function () {\n    if (startedAll && ! outstanding)\n      Log(\"Bound to proxy.\");\n  };\n  var makeCallback = function () {\n    outstanding++;\n    return function (err) {\n      if (err)\n        throw err;\n      outstanding--;\n      checkComplete();\n    };\n  };\n\n  // for now, have our (temporary) requiresAuth flag apply to all\n  // routes created by this process.\n  var requiresDdpAuth = !! proxyConfig.requiresAuth;\n  var requiresHttpAuth = (!! proxyConfig.requiresAuth) &&\n        (pid.app !== \"panel\" && pid.app !== \"auth\");\n\n  // XXX a current limitation is that we treat securePort and\n  // insecurePort as a global configuration parameter -- we assume\n  // that if the proxy wants us to ask for 8080 to get port 80 traffic\n  // on our default hostname, that's the same port that we would use\n  // to get traffic on some other hostname that our proxy listens\n  // for. Likewise, we assume that if the proxy can receive secure\n  // traffic for our domain, it can assume secure traffic for any\n  // domain! Hopefully this will get cleaned up before too long by\n  // pushing that logic into the proxy service, so we can just ask for\n  // port 80.\n\n  // XXX BUG: if our configuration changes, and bindPathPrefix\n  // changes, it appears that we will not remove the routes derived\n  // from the old bindPathPrefix from the proxy (until the process\n  // exits). It is not actually normal for bindPathPrefix to change,\n  // certainly not without a process restart for other reasons, but\n  // it'd be nice to fix.\n\n  _.each(routes, function (route) {\n    var parsedUrl = url.parse(route.url, /* parseQueryString */ false,\n                              /* slashesDenoteHost aka workRight */ true);\n    if (parsedUrl.protocol || parsedUrl.port || parsedUrl.search)\n      throw new Error(\"Bad url\");\n    parsedUrl.host = null;\n    parsedUrl.path = null;\n    if (! parsedUrl.hostname) {\n      parsedUrl.hostname = proxyConfig.bindHost;\n      if (! parsedUrl.pathname)\n        parsedUrl.pathname = \"\";\n      if (! parsedUrl.pathname.indexOf(\"/\") !== 0) {\n        // Relative path\n        parsedUrl.pathname = bindPathPrefix + parsedUrl.pathname;\n      }\n    }\n    var version = \"\";\n\n    var AppConfig = Package[\"application-configuration\"].AppConfig;\n    version = AppConfig.getStarForThisJob() || \"\";\n\n\n    var parsedDdpUrl = _.clone(parsedUrl);\n    parsedDdpUrl.protocol = \"ddp\";\n    // Node has a hardcoded list of protocols that get '://' instead\n    // of ':'. ddp needs to be added to that whitelist. Until then, we\n    // can set the undocumented attribute 'slashes' to get the right\n    // behavior. It's not clear whether than is by design or accident.\n    parsedDdpUrl.slashes = true;\n    parsedDdpUrl.port = '' + securePort;\n    var ddpUrl = url.format(parsedDdpUrl);\n\n    var proxyToHost, proxyToPort, proxyToPathPrefix;\n    if (! _.has(route, 'forwardTo')) {\n      proxyToHost = ourHost;\n      proxyToPort = ourPort;\n      proxyToPathPrefix = parsedUrl.pathname;\n    } else {\n      var parsedFwdUrl = url.parse(route.forwardTo, false, true);\n      if (! parsedFwdUrl.hostname || parsedFwdUrl.protocol)\n        throw new Error(\"Bad forward url\");\n      proxyToHost = parsedFwdUrl.hostname;\n      proxyToPort = parseInt(parsedFwdUrl.port || \"80\");\n      proxyToPathPrefix = parsedFwdUrl.pathname || \"\";\n    }\n\n    if (route.ddp) {\n      proxy.call('bindDdp', {\n        pid: pid,\n        bindTo: {\n          ddpUrl: ddpUrl,\n          insecurePort: insecurePort\n        },\n        proxyTo: {\n          tags: [version],\n          host: proxyToHost,\n          port: proxyToPort,\n          pathPrefix: proxyToPathPrefix + '/websocket'\n        },\n        requiresAuth: requiresDdpAuth\n      }, makeCallback());\n    }\n\n    if (route.http) {\n      proxy.call('bindHttp', {\n        pid: pid,\n        bindTo: {\n          host: parsedUrl.hostname,\n          port: insecurePort,\n          pathPrefix: parsedUrl.pathname\n        },\n        proxyTo: {\n          tags: [version],\n          host: proxyToHost,\n          port: proxyToPort,\n          pathPrefix: proxyToPathPrefix\n        },\n        requiresAuth: requiresHttpAuth\n      }, makeCallback());\n\n      // Only make the secure binding if we've been told that the\n      // proxy knows how terminate secure connections for us (has an\n      // appropriate cert, can bind the necessary port..)\n      if (proxyConfig.securePort !== null) {\n        proxy.call('bindHttp', {\n          pid: pid,\n          bindTo: {\n            host: parsedUrl.hostname,\n            port: securePort,\n            pathPrefix: parsedUrl.pathname,\n            ssl: true\n          },\n          proxyTo: {\n            tags: [version],\n            host: proxyToHost,\n            port: proxyToPort,\n            pathPrefix: proxyToPathPrefix\n          },\n          requiresAuth: requiresHttpAuth\n        }, makeCallback());\n      }\n    }\n  });\n\n  startedAll = true;\n  checkComplete();\n};\n\n// (Internal, unsupported interface -- subject to change)\n//\n// Listen for HTTP and/or DDP traffic and route it somewhere. Only\n// takes effect when using a proxy service.\n//\n// 'url' is the traffic that we want to route, interpreted relative to\n// the default URL where this app has been told to serve itself. It\n// may not have a scheme or port, but it may have a host and a path,\n// and if no host is provided the path need not be absolute. The\n// following cases are possible:\n//\n//   //somehost.com\n//     All incoming traffic for 'somehost.com'\n//   //somehost.com/foo/bar\n//     All incoming traffic for 'somehost.com', but only when\n//     the first two path components are 'foo' and 'bar'.\n//   /foo/bar\n//     Incoming traffic on our default host, but only when the\n//     first two path components are 'foo' and 'bar'.\n//   foo/bar\n//     Incoming traffic on our default host, but only when the path\n//     starts with our default path prefix, followed by 'foo' and\n//     'bar'.\n//\n// (Yes, these scheme-less URLs that start with '//' are legal URLs.)\n//\n// You can select either DDP traffic, HTTP traffic, or both. Both\n// secure and insecure traffic will be gathered (assuming the proxy\n// service is capable, eg, has appropriate certs and port mappings).\n//\n// With no 'forwardTo' option, the traffic is received by this process\n// for service by the hooks in this 'webapp' package. The original URL\n// is preserved (that is, if you bind \"/a\", and a user visits \"/a/b\",\n// the app receives a request with a path of \"/a/b\", not a path of\n// \"/b\").\n//\n// With 'forwardTo', the process is instead sent to some other remote\n// host. The URL is adjusted by stripping the path components in 'url'\n// and putting the path components in the 'forwardTo' URL in their\n// place. For example, if you forward \"//somehost/a\" to\n// \"//otherhost/x\", and the user types \"//somehost/a/b\" into their\n// browser, then otherhost will receive a request with a Host header\n// of \"somehost\" and a path of \"/x/b\".\n//\n// The routing continues until this process exits. For now, all of the\n// routes must be set up ahead of time, before the initial\n// registration with the proxy. Calling addRoute from the top level of\n// your JS should do the trick.\n//\n// When multiple routes are present that match a given request, the\n// most specific route wins. When routes with equal specificity are\n// present, the proxy service will distribute the traffic between\n// them.\n//\n// options may be:\n// - ddp: if true, the default, include DDP traffic. This includes\n//   both secure and insecure traffic, and both websocket and sockjs\n//   transports.\n// - http: if true, the default, include HTTP/HTTPS traffic.\n// - forwardTo: if provided, should be a URL with a host, optional\n//   path and port, and no scheme (the scheme will be derived from the\n//   traffic type; for now it will always be a http or ws connection,\n//   never https or wss, but we could add a forwardSecure flag to\n//   re-encrypt).\nvar routes = [];\nWebAppInternals.addRoute = function (url, options) {\n  options = _.extend({\n    ddp: true,\n    http: true\n  }, options || {});\n\n  if (proxy)\n    // In the future, lift this restriction\n    throw new Error(\"Too late to add routes\");\n\n  routes.push(_.extend({ url: url }, options));\n};\n\n// Receive traffic on our default URL.\nWebAppInternals.addRoute(\"\");\n\nrunWebAppServer();\n\n\nvar inlineScriptsAllowed = true;\n\nWebAppInternals.inlineScriptsAllowed = function () {\n  return inlineScriptsAllowed;\n};\n\nWebAppInternals.setInlineScriptsAllowed = function (value) {\n  inlineScriptsAllowed = value;\n  WebAppInternals.generateBoilerplate();\n};\n\nWebAppInternals.setBundledJsCssPrefix = function (prefix) {\n  bundledJsCssPrefix = prefix;\n  WebAppInternals.generateBoilerplate();\n};\n\n// Packages can call `WebAppInternals.addStaticJs` to specify static\n// JavaScript to be included in the app. This static JS will be inlined,\n// unless inline scripts have been disabled, in which case it will be\n// served under `/<sha1 of contents>`.\nvar additionalStaticJs = {};\nWebAppInternals.addStaticJs = function (contents) {\n  additionalStaticJs[\"/\" + sha1(contents) + \".js\"] = contents;\n};\n\n// Exported for tests\nWebAppInternals.getBoilerplate = getBoilerplate;\nWebAppInternals.additionalStaticJs = additionalStaticJs;\nWebAppInternals.validPid = validPid;\n"]}