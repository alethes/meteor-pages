)]}'
{"version":3,"file":"/packages/iron:router.js","sources":["iron:router/lib/utils.js","iron:router/lib/route.js","iron:router/lib/route_controller.js","iron:router/lib/router.js","iron:router/lib/client/location.js","iron:router/lib/client/router.js","iron:router/lib/client/wait_list.js","iron:router/lib/client/hooks.js","iron:router/lib/client/route_controller.js","iron:router/lib/client/ui/helpers.js","iron:router/lib/version_conflict_error.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sD;AACA,G;;AAEA,W;;AAEA,G;AACA,yD;AACA,G;;AAEA,gD;;AAEA,G;AACA,6C;AACA,E;AACA,2E;AACA,2E;AACA,G;;AAEA,0C;AACA,iB;AACA,yB;AACA,E;;AAEA,2B;AACA,2D;AACA,iD;AACA,G;AACA,E;;AAEA,wC;AACA,iB;AACA,c;AACA,E;;AAEA,G;AACA,mE;AACA,e;AACA,E;AACA,I;AACA,iC;AACA,6B;AACA,yC;AACA,+D;AACA,I;AACA,G;AACA,0C;AACA,W;AACA,c;AACA,c;AACA,Y;AACA,wF;;AAEA,yB;AACA,qB;AACA,2B;AACA,6C;AACA,uC;AACA,U;AACA,mB;AACA,c;AACA,iB;AACA,e;AACA,G;;AAEA,O;AACA,wB;AACA,a;AACA,6B;AACA,mC;AACA,iC;AACA,W;AACA,uB;AACA,I;AACA,E;;AAEA,2D;AACA,sB;AACA,iC;AACA,sD;AACA,I;AACA,E;;AAEA,G;AACA,8E;AACA,+E;AACA,e;AACA,E;AACA,Y;AACA,uD;AACA,+D;AACA,E;AACA,qC;AACA,G;;AAEA,6C;AACA,4B;AACA,Y;AACA,U;;AAEA,gC;AACA,kC;AACA,iB;AACA,4C;AACA,0B;AACA,e;AACA,yB;AACA,K;AACA,U;AACA,sB;AACA,G;;AAEA,uD;AACA,a;AACA,E;;AAEA,4C;AACA,+B;AACA,6B;AACA,E;;AAEA,G;AACA,uE;AACA,4E;AACA,+E;AACA,yD;AACA,G;;AAEA,2C;AACA,kD;AACA,4E;;AAEA,mD;AACA,6E;;AAEA,2B;AACA,0C;AACA,+B;AACA,G;;AAEA,oB;AACA,6B;AACA,G;;AAEA,oC;AACA,+B;AACA,qC;AACA,e;AACA,E;;AAEA,gC;AACA,W;AACA,c;AACA,kD;AACA,iB;AACA,M;AACA,e;AACA,E;;AAEA,+B;AACA,0B;AACA,wB;AACA,M;AACA,+C;AACA,E;;AAEA,sE;AACA,6B;AACA,uB;AACA,Q;AACA,kC;AACA,8B;AACA,G;;AAEA,mC;AACA,oD;AACA,K;AACA,E;;AAEA,+C;AACA,iB;AACA,gB;AACA,qB;;AAEA,0B;AACA,gC;;AAEA,sD;AACA,yC;AACA,Q;AACA,+B;AACA,qE;AACA,wE;AACA,K;AACA,G;;AAEA,iC;;AAEA,kD;;AAEA,oD;AACA,qD;AACA,wD;AACA,I;;AAEA,mB;AACA,qC;AACA,G;;AAEA,sC;AACA,kE;;AAEA,8C;;AAEA,qB;AACA,E;;AAEA,mC;AACA,gE;AACA,E;;AAEA,uC;AACA,oB;;AAEA,W;AACA,c;;AAEA,+C;AACA,kC;AACA,c;AACA,E;;AAEA,kC;AACA,yC;AACA,2E;AACA,gB;AACA,E;;AAEA,oC;AACA,iC;AACA,U;AACA,yC;AACA,kB;AACA,mD;AACA,iB;AACA,G;;AAEA,c;AACA,E;;AAEA,0B;AACA,2B;AACA,iB;AACA,I;;AAEA,sC;AACA,uC;AACA,I;;AAEA,iC;AACA,kC;AACA,G;AACA,E;;AAEA,2C;AACA,iD;;AAEA,mD;AACA,iD;AACA,kB;AACA,8B;AACA,oB;AACA,kC;;AAEA,8B;AACA,iC;AACA,sB;AACA,wB;AACA,S;AACA,K;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;;ACzRA,E;AACA,6E;AACA,+E;AACA,6E;AACA,kE;AACA,G;;AAEA,0C;AACA,W;AACA,E;AACA,e;AACA,iC;AACA,0D;;AAEA,e;AACA,qB;AACA,gE;;AAEA,4B;AACA,mC;;AAEA,yC;AACA,sC;;AAEA,uB;AACA,2B;;AAEA,2E;AACA,gD;;AAEA,mB;AACA,yC;AACA,uC;AACA,+B;;AAEA,8C;AACA,uC;AACA,M;AACA,2B;;AAEA,yC;;AAEA,iB;AACA,E;;AAEA,mB;AACA,qB;;AAEA,K;AACA,sB;AACA,I;AACA,qB;AACA,iB;AACA,K;;AAEA,wB;AACA,oB;AACA,a;AACA,+B;;AAEA,mB;;AAEA,8C;AACA,kC;AACA,Y;AACA,8B;AACA,gC;AACA,2C;AACA,iC;AACA,4B;AACA,iB;AACA,iD;AACA,kE;AACA,iE;AACA,gC;AACA,qB;AACA,uC;AACA,qB;AACA,uC;AACA,8B;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,oC;AACA,gC;;AAEA,2E;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,0E;AACA,8C;AACA,I;AACA,yB;AACA,oB;AACA,gB;AACA,K;;AAEA,2B;AACA,c;AACA,kB;;AAEA,oB;AACA,4B;AACA,oB;AACA,yB;AACA,Y;AACA,c;;AAEA,W;AACA,oG;;AAEA,mD;AACA,wB;AACA,wE;AACA,gB;AACA,2D;AACA,mC;AACA,Y;AACA,2B;AACA,K;;AAEA,2B;;AAEA,qC;AACA,oB;AACA,8C;;AAEA,qC;;AAEA,sB;AACA,6D;AACA,4C;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,kC;AACA,sC;;AAEA,oC;;AAEA,6C;AACA,sE;;AAEA,sC;AACA,wD;;AAEA,+B;AACA,wB;;AAEA,gB;AACA,I;;AAEA,K;AACA,0D;AACA,I;AACA,yB;AACA,sB;AACA,gB;AACA,K;AACA,yB;AACA,kD;AACA,I;;AAEA,yB;AACA,kD;AACA,I;;AAEA,uC;AACA,c;AACA,uB;AACA,e;AACA,0B;AACA,iC;AACA,a;AACA,c;AACA,gC;;AAEA,4B;AACA,0B;AACA,0B;AACA,mD;;AAEA,iC;AACA,4E;AACA,Y;AACA,8B;AACA,iB;AACA,iD;AACA,2E;AACA,gC;AACA,gC;AACA,0D;;AAEA,8C;AACA,yB;AACA,yC;AACA,qC;AACA,qB;AACA,a;;AAEA,qE;AACA,mF;AACA,iD;AACA,yB;AACA,uC;AACA,W;AACA,S;AACA,iB;AACA,gB;AACA,4B;AACA,+D;AACA,8B;AACA,4E;AACA,+B;AACA,uE;AACA,a;;AAEA,6D;AACA,oE;AACA,iD;AACA,yB;AACA,W;AACA,U;;AAEA,8B;AACA,4D;AACA,uE;AACA,qB;AACA,O;;AAEA,gC;AACA,kC;;AAEA,iB;AACA,gD;AACA,sB;AACA,iD;AACA,O;AACA,K;;AAEA,yE;AACA,4D;AACA,oE;;AAEA,yC;AACA,I;;AAEA,oC;AACA,yC;AACA,I;;AAEA,mC;AACA,0C;AACA,e;AACA,iC;AACA,0C;AACA,yC;AACA,Y;AACA,kB;AACA,K;AACA,I;;AAEA,4C;AACA,oB;AACA,gB;AACA,wB;AACA,mB;AACA,e;AACA,kB;;AAEA,0C;AACA,gC;;AAEA,6C;AACA,0C;AACA,8C;AACA,wB;AACA,sD;AACA,O;;AAEA,wB;AACA,M;;AAEA,wD;AACA,gC;AACA,oC;AACA,sD;AACA,2C;AACA,mC;AACA,uB;AACA,6F;;AAEA,oB;AACA,mC;;AAEA,sB;AACA,I;;AAEA,2C;AACA,+C;;AAEA,qC;AACA,iB;AACA,gC;AACA,wB;AACA,yB;AACA,O;;AAEA,6C;AACA,I;;AAEA,2C;AACA,6C;AACA,gF;AACA,E;;;;;;;;;;;;;;;;;;;ACnUA,qD;AACA,kB;;AAEA,sC;AACA,yD;;AAEA,gC;AACA,wD;;AAEA,yC;;AAEA,uB;AACA,qB;;AAEA,iC;AACA,qC;AACA,yC;AACA,8C;;AAEA,yC;AACA,iC;AACA,E;;AAEA,6B;AACA,+B;;AAEA,K;AACA,+E;AACA,W;AACA,I;AACA,iC;AACA,mC;AACA,uB;AACA,wB;AACA,K;AACA,kC;AACA,c;;AAEA,yB;AACA,8C;;AAEA,iC;AACA,2D;AACA,mB;;AAEA,kC;AACA,mD;AACA,mB;;AAEA,a;AACA,I;AACA,uB;AACA,8B;AACA,2D;AACA,mB;;AAEA,wB;AACA,+B;AACA,2D;AACA,mB;;AAEA,qC;AACA,qB;AACA,I;;AAEA,2C;AACA,oB;AACA,gC;;AAEA,8B;AACA,mD;;AAEA,iC;AACA,4D;;AAEA,yB;;AAEA,0C;AACA,wB;;AAEA,iD;AACA,2B;AACA,kB;;AAEA,iD;AACA,uD;AACA,e;AACA,2B;AACA,2C;AACA,kC;AACA,O;;AAEA,8C;AACA,yD;AACA,O;;AAEA,4D;AACA,+D;AACA,iD;AACA,qB;;AAEA,yB;AACA,gF;AACA,M;AACA,6D;AACA,uD;AACA,M;;;AAGA,yD;AACA,sC;AACA,0E;AACA,sC;AACA,6B;AACA,4B;AACA,c;;AAEA,gC;AACA,sE;;AAEA,a;AACA,8B;AACA,2D;;AAEA,wB;AACA,sD;;AAEA,6D;;AAEA,oB;AACA,mD;AACA,uD;AACA,iD;AACA,8B;AACA,2C;AACA,Q;AACA,uB;;AAEA,8B;AACA,yB;AACA,0B;AACA,+B;AACA,0B;AACA,oB;;AAEA,yB;AACA,+B;AACA,sB;AACA,M;;AAEA,oD;AACA,oC;;AAEA,uC;AACA,sC;AACA,K;;AAEA,kC;AACA,oB;AACA,I;;AAEA,uB;AACA,uC;AACA,I;;AAEA,uB;AACA,oC;AACA,I;;AAEA,kC;AACA,oB;;AAEA,uB;AACA,a;;AAEA,2B;AACA,4B;AACA,0B;AACA,wB;AACA,I;;AAEA,qB;AACA,uC;AACA,G;AACA,E;;AAEA,2B;AACA,K;AACA,iC;AACA,I;AACA,yE;AACA,K;;AAEA,iC;AACA,yC;;AAEA,iE;AACA,uB;;AAEA,M;AACA,Q;AACA,8E;AACA,mB;;AAEA,wB;AACA,uD;AACA,8C;;AAEA,mB;AACA,iD;AACA,kC;AACA,a;AACA,O;AACA,uC;AACA,6C;AACA,iC;AACA,S;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC3NA,iC;AACA,kB;;AAEA,0B;;AAEA,K;AACA,oE;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,mB;;AAEA,K;AACA,4C;AACA,yB;AACA,K;AACA,4B;AACA,4C;AACA,6D;;AAEA,yB;AACA,iD;AACA,iC;;AAEA,e;AACA,+C;AACA,sD;AACA,U;AACA,2C;AACA,+C;AACA,M;AACA,K;;AAEA,oE;AACA,oC;AACA,8B;AACA,wB;AACA,yB;AACA,qB;AACA,S;;AAEA,+C;AACA,K;AACA,K;AACA,E;;AAEA,yB;AACA,U;AACA,W;AACA,mB;AACA,kB;AACA,W;;AAEA,4C;AACA,6C;AACA,mD;AACA,qD;AACA,U;AACA,E;;AAEA,gC;AACA,kB;AACA,6B;AACA,2B;AACA,oB;AACA,E;;AAEA,wB;AACA,0B;;AAEA,K;AACA,4E;AACA,wE;AACA,I;AACA,4B;AACA,yB;AACA,gB;AACA,K;;AAEA,iC;AACA,oB;;AAEA,4B;AACA,sC;AACA,oC;;AAEA,4C;AACA,kD;AACA,+B;AACA,kE;AACA,mC;AACA,W;;AAEA,kC;AACA,O;AACA,O;AACA,I;AACA,qE;AACA,qC;AACA,wB;AACA,wE;AACA,mC;AACA,W;;AAEA,wC;AACA,O;AACA,O;;AAEA,sC;AACA,uE;;AAEA,6C;AACA,qF;;AAEA,gB;AACA,I;;AAEA,yC;AACA,qD;AACA,mB;AACA,8D;AACA,4B;AACA,I;;AAEA,gD;AACA,4D;AACA,mB;AACA,qE;AACA,4B;AACA,I;;AAEA,kD;AACA,kB;;AAEA,mC;AACA,+B;;AAEA,iC;AACA,uD;;AAEA,qB;AACA,mE;AACA,K;;AAEA,0C;AACA,gB;AACA,I;;AAEA,K;AACA,I;AACA,kE;AACA,iF;AACA,I;AACA,wE;AACA,uE;AACA,6C;AACA,yB;AACA,gB;AACA,I;AACA,K;;AAEA,0C;AACA,2B;;AAEA,qB;AACA,iD;AACA,uB;AACA,qD;;AAEA,iE;;AAEA,gB;AACA,I;;AAEA,K;AACA,I;AACA,uE;AACA,wD;AACA,I;AACA,wD;AACA,sE;AACA,0D;AACA,gB;AACA,I;AACA,K;;AAEA,kC;AACA,mB;;AAEA,oD;AACA,iC;;AAEA,4D;AACA,e;;AAEA,0D;AACA,e;;AAEA,4B;AACA,O;;AAEA,iB;AACA,I;;;AAGA,K;AACA,+E;AACA,+C;AACA,I;AACA,a;AACA,8B;AACA,4B;AACA,S;AACA,I;AACA,0B;AACA,0B;AACA,iB;AACA,K;;AAEA,sB;AACA,kC;AACA,6D;AACA,kB;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,iE;AACA,I;AACA,+C;AACA,iE;AACA,oB;AACA,gB;AACA,K;;AAEA,mC;AACA,c;;AAEA,mE;;AAEA,iC;AACA,sB;AACA,Q;AACA,6C;;AAEA,8B;AACA,4B;AACA,iB;AACA,I;;AAEA,+C;AACA,uC;AACA,qB;AACA,uI;AACA,gD;AACA,I;;AAEA,8C;AACA,uC;AACA,qB;AACA,yI;AACA,+C;AACA,I;;AAEA,0B;AACA,qE;AACA,I;AACA,I;AACA,0C;AACA,iC;AACA,I;AACA,gB;AACA,iD;AACA,I;AACA,gE;AACA,6C;AACA,I;AACA,wD;AACA,6B;AACA,I;;AAEA,kC;AACA,oB;AACA,sD;;AAEA,0D;;AAEA,+D;AACA,oC;AACA,4D;AACA,a;AACA,K;;AAEA,2B;AACA,2C;AACA,yB;AACA,2B;AACA,qC;AACA,M;;AAEA,qE;AACA,wE;AACA,uE;AACA,0D;AACA,gC;AACA,mD;AACA,Q;AACA,Y;AACA,I;;AAEA,yC;AACA,mD;AACA,I;;AAEA,6C;AACA,sE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC/TA,8B;AACA,2E;AACA,sD;AACA,0D;AACA,oB;AACA,4D;AACA,+E;AACA,8E;AACA,a;AACA,E;;AAEA,yB;AACA,6F;AACA,C;;AAEA,kB;;AAEA,mC;AACA,kD;AACA,E;;AAEA,6C;AACA,qC;AACA,oC;AACA,E;;AAEA,gC;AACA,e;AACA,sB;AACA,E;;AAEA,iC;AACA,e;AACA,2B;AACA,E;;AAEA,4C;AACA,0B;;AAEA,kC;;AAEA,wB;AACA,e;AACA,Q;AACA,8B;AACA,sB;AACA,uC;AACA,G;;AAEA,uC;AACA,2B;AACA,sC;AACA,2B;AACA,gC;AACA,+E;AACA,M;AACA,4E;AACA,E;;AAEA,mC;AACA,yD;AACA,oC;AACA,sB;AACA,yB;;AAEA,8D;AACA,kB;;AAEA,0B;AACA,C;;AAEA,qE;AACA,4C;;AAEA,wB;AACA,yC;AACA,M;AACA,0B;AACA,E;;AAEA,wE;AACA,4C;AACA,2B;AACA,+B;AACA,2B;AACA,4B;;AAEA,4C;;AAEA,2B;AACA,4C;AACA,M;AACA,0B;AACA,E;;AAEA,qC;AACA,mD;AACA,E;;AAEA,uC;AACA,wC;AACA,E;;AAEA,kC;AACA,qB;AACA,W;;AAEA,4B;AACA,wB;AACA,wD;AACA,6B;AACA,8E;AACA,mE;AACA,6E;AACA,6D;AACA,2B;AACA,qG;AACA,E;;AAEA,iC;AACA,8B;AACA,yB;AACA,E;;;;;;;;;;;;;;;;;;;AC1HA,+E;AACA,a;AACA,+E;AACA,0C;AACA,sB;AACA,mF;AACA,I;AACA,E;;AAEA,+E;AACA,gB;AACA,+E;AACA,uC;AACA,mC;AACA,oB;;AAEA,4D;AACA,uE;;AAEA,4B;AACA,I;AACA,4B;;AAEA,O;AACA,+E;AACA,wE;AACA,wB;AACA,M;AACA,mB;AACA,O;AACA,mC;;AAEA,O;AACA,gD;AACA,M;AACA,mB;AACA,O;AACA,8C;;AAEA,O;AACA,kE;AACA,kD;AACA,Q;AACA,oB;AACA,Q;AACA,kC;;AAEA,gC;AACA,gC;AACA,8C;AACA,4B;AACA,6C;AACA,uB;AACA,S;AACA,O;;AAEA,gC;AACA,4E;AACA,+E;AACA,6B;AACA,4E;;AAEA,M;AACA,8D;AACA,Y;AACA,e;AACA,kB;AACA,oB;AACA,gB;AACA,e;AACA,+B;AACA,uC;AACA,sB;AACA,sE;AACA,gE;AACA,Q;AACA,O;AACA,M;AACA,I;;AAEA,wC;AACA,iD;;AAEA,gD;AACA,4C;AACA,sD;;AAEA,kB;AACA,I;;AAEA,0C;AACA,iC;AACA,wB;AACA,oB;AACA,K;;AAEA,gD;AACA,gB;AACA,I;;AAEA,kC;AACA,+B;AACA,gB;AACA,I;;AAEA,K;AACA,6E;AACA,2E;AACA,I;AACA,iD;AACA,iF;AACA,8B;AACA,gB;AACA,K;;AAEA,4B;AACA,wC;AACA,qC;AACA,U;AACA,mC;AACA,qC;AACA,K;AACA,I;;AAEA,6C;AACA,oB;;AAEA,6C;AACA,kD;;AAEA,sD;AACA,mB;AACA,O;;AAEA,2D;;AAEA,yC;AACA,4B;AACA,O;AACA,I;;AAEA,kC;AACA,oD;;AAEA,gD;AACA,oC;AACA,K;AACA,I;;AAEA,K;AACA,+E;AACA,qE;AACA,I;AACA,c;AACA,I;AACA,8C;AACA,2D;AACA,I;AACA,oC;AACA,mC;AACA,4B;AACA,oC;AACA,gB;AACA,K;;AAEA,mD;AACA,oB;AACA,6B;AACA,c;AACA,a;AACA,mB;AACA,mB;AACA,a;AACA,I;AACA,2D;AACA,0D;AACA,uB;AACA,8B;AACA,gC;AACA,2C;AACA,6B;AACA,0B;AACA,S;AACA,M;;AAEA,yC;AACA,6B;AACA,uB;AACA,M;AACA,6E;AACA,2C;AACA,+B;AACA,oG;AACA,e;AACA,O;AACA,M;AACA,+D;AACA,wE;AACA,yE;AACA,yE;AACA,e;AACA,yC;AACA,Y;AACA,2C;AACA,qE;AACA,yC;AACA,sD;AACA,iC;AACA,K;AACA,I;;AAEA,uB;AACA,2B;;AAEA,4C;AACA,iC;AACA,I;;AAEA,2B;AACA,2B;;AAEA,yB;AACA,8C;AACA,wB;AACA,M;AACA,mD;AACA,2B;AACA,O;AACA,I;;AAEA,2B;AACA,8F;AACA,I;;AAEA,6B;AACA,mE;AACA,I;;AAEA,K;AACA,2E;AACA,yD;AACA,I;AACA,gB;AACA,K;;AAEA,sB;AACA,oB;;AAEA,+B;;AAEA,0B;AACA,I;AACA,2D;AACA,2B;AACA,I;AACA,sB;;AAEA,+B;AACA,mB;AACA,oC;AACA,mE;AACA,O;AACA,I;;AAEA,K;AACA,yE;AACA,I;AACA,gB;AACA,K;;AAEA,qB;AACA,2B;;AAEA,wB;AACA,0B;;AAEA,kC;AACA,uC;AACA,I;;AAEA,K;AACA,sE;AACA,I;AACA,gB;AACA,K;AACA,yC;AACA,2B;AACA,I;AACA,E;AACA,K;AACA,oE;AACA,0B;AACA,4E;AACA,yC;AACA,+E;AACA,I;AACA,gB;AACA,K;AACA,6C;AACA,yC;AACA,6B;AACA,+C;AACA,iG;AACA,yD;AACA,oD;AACA,+C;AACA,U;AACA,Y;AACA,wE;AACA,K;AACA,I;AACA,E;AACA,wB;AACA,6B;AACA,4D;AACA,uB;AACA,iD;;AAEA,4E;AACA,sC;;AAEA,oD;AACA,uC;AACA,+B;AACA,a;;AAEA,iE;AACA,oB;AACA,a;;AAEA,8C;AACA,a;;AAEA,+B;AACA,kB;AACA,a;;AAEA,mC;AACA,0C;AACA,a;;AAEA,oE;AACA,4C;AACA,uB;AACA,kB;AACA,G;AACA,G;;AAEA,G;AACA,uD;AACA,E;AACA,c;AACA,kB;AACA,G;;AAEA,wB;;AAEA,qB;AACA,2D;AACA,6E;AACA,E;AACA,oD;AACA,yD;AACA,iC;AACA,C;;;;;;;;;;;;;;;;;;;AC5WA,+E;AACA,a;AACA,+E;AACA,+B;;AAEA,+E;AACA,a;AACA,+E;;AAEA,G;AACA,qD;AACA,qD;AACA,gD;AACA,6C;AACA,G;AACA,sC;AACA,gB;AACA,kC;;AAEA,a;AACA,+B;AACA,kB;AACA,G;;AAEA,c;AACA,E;;AAEA,G;AACA,yE;AACA,wD;AACA,E;AACA,6B;AACA,E;AACA,6B;AACA,kB;AACA,mB;AACA,M;AACA,G;AACA,sD;AACA,yC;AACA,2D;;AAEA,oC;AACA,mC;AACA,0E;AACA,K;AACA,mD;AACA,4D;AACA,mE;AACA,M;AACA,K;AACA,E;;;AAGA,+E;AACA,c;AACA,+E;AACA,G;AACA,+E;AACA,8E;AACA,8E;AACA,E;AACA,6E;AACA,8E;AACA,8E;AACA,+B;AACA,G;AACA,wB;AACA,uC;AACA,mB;AACA,0B;AACA,E;;AAEA,G;AACA,8C;AACA,G;AACA,yC;AACA,kB;;AAEA,2C;;AAEA,2C;;AAEA,wD;AACA,gC;;AAEA,8E;AACA,gB;AACA,4B;;AAEA,2C;AACA,0C;AACA,qE;AACA,0B;;AAEA,iD;;AAEA,uD;AACA,gC;AACA,8B;AACA,mF;AACA,8B;AACA,oF;AACA,8B;;AAEA,4B;;AAEA,4D;AACA,iC;AACA,iE;AACA,iC;AACA,O;;AAEA,2B;;AAEA,qB;AACA,2C;AACA,sE;AACA,uE;AACA,6C;;AAEA,oE;AACA,qC;AACA,iC;AACA,sB;;AAEA,iD;AACA,8D;;AAEA,uC;AACA,kC;;AAEA,0C;AACA,uC;AACA,W;AACA,W;AACA,S;AACA,K;AACA,K;AACA,E;;AAEA,wC;AACA,0B;AACA,mC;AACA,E;;AAEA,uC;AACA,kD;AACA,mB;AACA,E;;;;;;;;;;;;;;;;;;;ACrJA,gB;AACA,kC;AACA,a;;AAEA,sB;AACA,a;AACA,I;AACA,yB;AACA,a;;AAEA,2B;;AAEA,yE;AACA,qD;;AAEA,iB;AACA,0B;AACA,6B;AACA,gB;AACA,O;AACA,K;AACA,I;;AAEA,6B;AACA,oB;AACA,a;;AAEA,wB;AACA,oD;;AAEA,iB;AACA,0B;AACA,6B;AACA,gB;AACA,O;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACrCA,sB;AACA,0B;AACA,iB;AACA,W;AACA,mG;AACA,E;;AAEA,0C;AACA,sB;AACA,mF;AACA,I;AACA,E;;AAEA,iD;AACA,4B;AACA,oB;;AAEA,iE;;AAEA,kC;;AAEA,gE;AACA,kB;;AAEA,2C;;AAEA,wE;AACA,qC;;AAEA,wC;AACA,Y;AACA,e;AACA,kB;AACA,mB;AACA,mC;AACA,2C;AACA,yB;AACA,kE;AACA,0E;AACA,Q;AACA,O;AACA,I;;AAEA,0B;AACA,8C;AACA,I;;AAEA,sB;AACA,kC;AACA,I;;AAEA,K;AACA,gF;AACA,wB;AACA,gB;AACA,K;;AAEA,mC;AACA,8C;AACA,I;;AAEA,wD;AACA,oB;AACA,yD;;AAEA,6B;AACA,yB;AACA,wB;AACA,O;AACA,O;AACA,I;;AAEA,qC;AACA,iD;AACA,I;;AAEA,+B;AACA,0C;AACA,qD;AACA,I;;AAEA,sC;AACA,Y;;AAEA,qD;AACA,iB;AACA,yD;AACA,iB;AACA,Q;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,gF;AACA,U;AACA,+B;AACA,I;AACA,wB;AACA,uB;AACA,4B;AACA,6B;AACA,K;;AAEA,6B;AACA,gC;;AAEA,kF;AACA,gE;AACA,8D;AACA,qD;AACA,+C;;AAEA,yB;AACA,gC;AACA,+B;AACA,4B;AACA,+B;AACA,I;;AAEA,K;AACA,gF;AACA,+D;AACA,K;AACA,2D;AACA,iE;AACA,K;;AAEA,wC;AACA,W;AACA,iB;AACA,e;AACA,oB;;AAEA,gC;AACA,4C;AACA,2B;AACA,Y;AACA,8B;AACA,sB;AACA,mC;AACA,K;AACA,I;AACA,E;AACA,6B;AACA,oB;AACA,uD;AACA,I;AACA,mD;AACA,6B;AACA,O;AACA,I;;AAEA,K;AACA,iC;AACA,K;AACA,uB;AACA,oB;;AAEA,Y;AACA,yE;AACA,sE;AACA,qD;AACA,a;;AAEA,wB;AACA,iD;AACA,8B;AACA,S;AACA,0B;AACA,8D;AACA,Y;AACA,8B;AACA,K;;AAEA,gB;AACA,I;;AAEA,uB;AACA,kB;AACA,I;;AAEA,K;AACA,sD;AACA,+D;AACA,oE;AACA,sE;AACA,6E;AACA,uE;AACA,2E;AACA,wD;AACA,K;AACA,kC;AACA,oB;;AAEA,oC;AACA,uB;AACA,a;;AAEA,8B;AACA,+D;AACA,M;;AAEA,4B;AACA,+B;AACA,6C;AACA,Y;AACA,e;AACA,K;AACA,I;;AAEA,qB;AACA,oB;AACA,qC;;AAEA,iE;AACA,0B;AACA,uB;AACA,oE;;AAEA,0B;AACA,2B;;AAEA,qD;AACA,0B;AACA,gC;;AAEA,iC;AACA,+C;AACA,mL;AACA,mB;AACA,W;AACA,U;;AAEA,a;AACA,sD;AACA,mB;AACA,8B;AACA,S;AACA,Q;AACA,M;;AAEA,kD;AACA,gF;AACA,6E;AACA,2C;AACA,4B;AACA,M;AACA,4D;AACA,8E;AACA,iC;AACA,6C;AACA,U;;AAEA,iC;AACA,iB;AACA,6C;AACA,wE;AACA,+E;AACA,Y;;AAEA,sB;;AAEA,0B;AACA,S;;AAEA,iC;AACA,2E;AACA,4E;AACA,+E;AACA,4C;AACA,kG;AACA,6B;AACA,mB;AACA,+C;AACA,oE;AACA,mE;AACA,W;;AAEA,iB;AACA,iF;AACA,4B;AACA,oG;;AAEA,kD;AACA,kD;AACA,2C;AACA,W;AACA,Q;AACA,+D;AACA,6B;AACA,mB;;AAEA,wB;AACA,8B;;AAEA,kC;AACA,6C;AACA,a;AACA,W;AACA,W;AACA,S;AACA,Q;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AChTA,oB;;AAEA,kC;AACA,2C;AACA,E;;AAEA,qD;AACA,8B;AACA,wB;AACA,8B;AACA,G;;AAEA,gC;AACA,4D;AACA,uB;AACA,yB;;AAEA,+D;AACA,sB;AACA,2B;;AAEA,U;AACA,yB;AACA,mB;AACA,iB;AACA,c;AACA,I;AACA,E;;AAEA,0B;;AAEA,K;AACA,iB;AACA,I;AACA,qC;AACA,+D;AACA,qE;AACA,K;;AAEA,0C;AACA,8D;;AAEA,qD;AACA,wB;AACA,qB;AACA,O;AACA,I;;AAEA,K;AACA,qD;AACA,I;AACA,K;AACA,yC;AACA,8D;;AAEA,oD;AACA,wB;AACA,qB;AACA,O;AACA,G;AACA,G;;AAEA,gD;AACA,kC;AACA,G;;;;;;;;;;;;;;;;;;;AChEA,qC;AACA,wB;AACA,uI;AACA,+F;AACA,sB;AACA,sE;AACA,S;AACA,wC;AACA,0C;AACA,oD;AACA,kD;AACA,O;AACA,0D;AACA,iC;AACA,yC;AACA,S;AACA,K;AACA,C","sourcesContent":["/**\n * Utility methods available privately to the package.\n */\n\nUtils = {};\n\n/**\n * global object on node or window object in the browser.\n */\n\nUtils.global = (function () { return this; })();\n\n/**\n * Assert that the given condition is truthy.\n *\n * @param {Boolean} condition The boolean condition to test for truthiness.\n * @param {String} msg The error message to show if the condition is falsy.\n */\n\nUtils.assert = function (condition, msg) {\n  if (!condition)\n    throw new Error(msg);\n};\n\nvar warn = function (msg) {\n  if (!Router || Router.options.supressWarnings !== true) {\n    console && console.warn && console.warn(msg);\n  }\n};\n\nUtils.warn = function (condition, msg) {\n  if (!condition)\n    warn(msg);\n};\n\n/**\n * deprecatation notice to the user which can be a string or object\n * of the form:\n *\n * {\n *  name: 'somePropertyOrMethod',\n *  where: 'RouteController',\n *  instead: 'someOtherPropertyOrMethod',\n *  message: ':name is deprecated. Please use :instead instead'\n * }\n */\nUtils.notifyDeprecated = function (info) {\n  var name;\n  var instead;\n  var message;\n  var where;\n  var defaultMessage = \"[:where] ':name' is deprecated. Please use ':instead' instead.\";\n\n  if (_.isObject(info)) {\n    name = info.name;\n    instead = info.instead;\n    message = info.message || defaultMessage;\n    where = info.where || 'IronRouter';\n  } else {\n    message = info;\n    name = '';\n    instead = '';\n    where = '';\n  }\n\n  warn(\n      '<deprecated> ' + \n      message\n      .replace(':name', name)\n      .replace(':instead', instead)\n      .replace(':where', where) +\n      ' ' +\n      (new Error).stack\n  );\n};\n\nUtils.withDeprecatedNotice = function (info, fn, thisArg) {\n  return function () {\n    Utils.notifyDeprecated(info);\n    return fn && fn.apply(thisArg || this, arguments);\n  };\n};\n\n/**\n * Given the name of a property, resolves to the value. Works with namespacing\n * too. If first parameter is already a value that isn't a string it's returned\n * immediately.\n *\n * Examples:\n *  'SomeClass' => window.SomeClass || global.someClass\n *  'App.namespace.SomeClass' => window.App.namespace.SomeClass\n *\n * @param {String|Object} nameOrValue\n */\n\nUtils.resolveValue = function (nameOrValue) {\n  var global = Utils.global;\n  var parts;\n  var ptr;\n\n  if (_.isString(nameOrValue)) {\n    parts = nameOrValue.split('.')\n    ptr = global;\n    for (var i = 0; i < parts.length; i++) {\n      ptr = ptr[parts[i]];\n      if (!ptr)\n        return undefined;\n    }\n  } else {\n    ptr = nameOrValue;\n  }\n\n  // final position of ptr should be the resolved value\n  return ptr;\n};\n\nUtils.hasOwnProperty = function (obj, key) {\n  var prop = {}.hasOwnProperty;\n  return prop.call(obj, key);\n};\n\n/**\n * Don't mess with this function. It's exactly the same as the compiled\n * coffeescript mechanism. If you change it we can't guarantee that our code\n * will work when used with Coffeescript. One exception is putting in a runtime\n * check that both child and parent are of type Function.\n */\n\nUtils.inherits = function (child, parent) {\n  if (Utils.typeOf(child) !== '[object Function]')\n    throw new Error('First parameter to Utils.inherits must be a function');\n\n  if (Utils.typeOf(parent) !== '[object Function]')\n    throw new Error('Second parameter to Utils.inherits must be a function');\n\n  for (var key in parent) {\n    if (Utils.hasOwnProperty(parent, key))\n      child[key] = parent[key];\n  }\n\n  function ctor () {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n};\n\nUtils.toArray = function (obj) {\n  if (!obj)\n    return [];\n  else if (Utils.typeOf(obj) !== '[object Array]')\n    return [obj];\n  else\n    return obj;\n};\n\nUtils.typeOf = function (obj) {\n  if (obj && obj.typeName)\n    return obj.typeName;\n  else\n    return Object.prototype.toString.call(obj);\n};\n\nUtils.extend = function (Super, definition, onBeforeExtendPrototype) {\n  if (arguments.length === 1)\n    definition = Super;\n  else {\n    definition = definition || {};\n    definition.extend = Super;\n  }\n\n  return Utils.create(definition, {\n    onBeforeExtendPrototype: onBeforeExtendPrototype\n  });\n};\n\nUtils.create = function (definition, options) {\n  var Constructor\n    , extendFrom\n    , savedPrototype;\n\n  options = options || {};\n  definition = definition || {};\n\n  if (Utils.hasOwnProperty(definition, 'constructor'))\n    Constructor = definition.constructor;\n  else {\n    Constructor = function () {\n      if (Constructor.__super__ && Constructor.__super__.constructor)\n        return Constructor.__super__.constructor.apply(this, arguments);\n    }\n  }\n\n  extendFrom = definition.extend;\n\n  if (definition.extend) delete definition.extend;\n\n  var inherit = function (Child, Super, prototype) {\n    Utils.inherits(Child, Utils.resolveValue(Super));\n    if (prototype) _.extend(Child.prototype, prototype);\n  };\n\n  if (extendFrom) {\n    inherit(Constructor, extendFrom);\n  }\n\n  if (options.onBeforeExtendPrototype)\n    options.onBeforeExtendPrototype.call(Constructor, definition);\n\n  _.extend(Constructor.prototype, definition);\n\n  return Constructor;\n};\n\nUtils.capitalize = function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1, str.length);\n};\n\nUtils.upperCamelCase = function (str) {\n  var re = /_|-|\\./;\n\n  if (!str)\n    return '';\n\n  return _.map(str.split(re), function (word) {\n    return Utils.capitalize(word);\n  }).join('');\n};\n\nUtils.camelCase = function (str) {\n  var output = Utils.upperCamelCase(str);\n  output = output.charAt(0).toLowerCase() + output.slice(1, output.length);\n  return output;\n};\n\nUtils.pick = function (/* args */) {\n  var args = _.toArray(arguments)\n    , arg;\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (typeof arg !== 'undefined' && arg !== null)\n      return arg;\n  }\n\n  return null;\n};\n\nUtils.StringConverters = {\n  'none': function(input) {\n    return input;\n  },\n\n  'upperCamelCase': function (input) {\n    return Utils.upperCamelCase(input);\n  },\n\n  'camelCase': function (input) {\n    return Utils.camelCase(input);\n  }\n};\n\nUtils.rewriteLegacyHooks = function (obj) {\n  var legacyToNew = IronRouter.LEGACY_HOOK_TYPES;\n\n  _.each(legacyToNew, function (newHook, oldHook) {\n    // only look on the immediate object, not its\n    // proto chain\n    if (_.has(obj, oldHook)) {\n      hasOld = true;\n      obj[newHook] = obj[oldHook];\n\n      Utils.notifyDeprecated({\n        where: 'RouteController',\n        name: oldHook,\n        instead: newHook\n      });\n    }\n  });\n};\n\n","/*\n * Inspiration and some code for the compilation of routes comes from pagejs.\n * The original has been modified to better handle hash fragments, and to store\n * the regular expression on the Route instance. Also, the resolve method has\n * been added to return a resolved path given a parameters object.\n */\n\nRoute = function (router, name, options) {\n  var path;\n  \n  Utils.assert(\n    router instanceof IronRouter,\n    \"Route constructor first parameter must be a Router\");\n\n  Utils.assert(\n    _.isString(name),\n    \"Route constructor second parameter must be a String name\");\n\n  if (_.isFunction(options))\n    options = { handler: options };\n\n  options = this.options = options || {};\n  path = options.path || ('/' + name);\n\n  this.router = router;\n  this.originalPath = path;\n\n  if (_.isString(this.originalPath) && this.originalPath.charAt(0) !== '/')\n    this.originalPath = '/' + this.originalPath;\n\n  this.name = name;\n  this.where = options.where || 'client';\n  this.controller = options.controller;\n  this.action = options.action;\n\n  if (typeof options.reactive !== 'undefined')\n    this.isReactive = options.reactive;\n  else\n    this.isReactive = true;\n\n  Utils.rewriteLegacyHooks(this.options);\n\n  this.compile();\n};\n\nRoute.prototype = {\n  constructor: Route,\n\n  /**\n   * Compile the path.\n   *\n   *  @return {Route}\n   *  @api public\n   */\n\n  compile: function () {\n    var self = this;\n    var path;\n    var options = self.options;\n\n    this.keys = [];\n\n    if (self.originalPath instanceof RegExp) {\n      self.re = self.originalPath;\n    } else {\n      path = self.originalPath\n        .replace(/(.)\\/$/, '$1')\n        .concat(options.strict ? '' : '/?')\n        .replace(/\\/\\(/g, '(?:/')\n        .replace(/#/, '/?#')\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional){\n            self.keys.push({ name: key, optional: !! optional });\n            slash = slash || '';\n            return ''\n              + (optional ? '' : slash)\n              + '(?:'\n              + (optional ? slash : '')\n              + (format || '')\n              + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n              + (optional || '');\n          }\n        )\n        .replace(/([\\/.])/g, '\\\\$1')\n        .replace(/\\*/g, '(.*)');\n\n      self.re = new RegExp('^' + path + '$', options.sensitive ? '' : 'i');\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns an array of parameters given a path. The array may have named\n   * properties in addition to indexed values.\n   *\n   * @param {String} path\n   * @return {Array}\n   * @api public\n   */\n\n  params: function (path) {\n    if (!path)\n      return null;\n\n    var params = [];\n    var m = this.exec(path);\n    var queryString;\n    var keys = this.keys;\n    var key;\n    var value;\n\n    if (!m)\n      throw new Error('The route named \"' + this.name + '\" does not match the path \"' + path + '\"');\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      key = keys[i - 1];\n      value = typeof m[i] == 'string' ? decodeURIComponent(m[i]) : m[i];\n      if (key) {\n        params[key.name] = params[key.name] !== undefined ?\n          params[key.name] : value;\n      } else\n        params.push(value);\n    }\n\n    path = decodeURI(path);\n\n    queryString = path.split('?')[1];\n    if (queryString)\n      queryString = queryString.split('#')[0];\n\n    params.hash = path.split('#')[1];\n\n    if (queryString) {\n      _.each(queryString.split('&'), function (paramString) {\n        paramParts = paramString.split('=');\n        params[paramParts[0]] = decodeURIComponent(paramParts[1]);\n      });\n    }\n\n    return params;\n  },\n\n  normalizePath: function (path) {\n    var origin = Meteor.absoluteUrl();\n\n    path = path.replace(origin, '');\n\n    var queryStringIndex = path.indexOf('?');\n    path = ~queryStringIndex ? path.slice(0, queryStringIndex) : path;\n\n    var hashIndex = path.indexOf('#');\n    path = ~hashIndex ? path.slice(0, hashIndex) : path;\n\n    if (path.charAt(0) !== '/')\n      path = '/' + path;\n\n    return path;\n  },\n\n  /**\n   * Returns true if the path matches and false otherwise.\n   *\n   * @param {String} path\n   * @return {Boolean}\n   * @api public\n   */\n  test: function (path) {\n    return this.re.test(this.normalizePath(path));\n  },\n\n  exec: function (path) {\n    return this.re.exec(this.normalizePath(path));\n  },\n\n  resolve: function (params, options) {\n    var value;\n    var isValueDefined;\n    var result;\n    var wildCardCount = 0;\n    var path = this.originalPath;\n    var hash;\n    var query;\n    var isMissingParams = false;\n\n    options = options || {};\n    params = params || [];\n    query = options.query;\n    hash = options.hash && options.hash.toString();\n\n    if (path instanceof RegExp) {\n      throw new Error('Cannot currently resolve a regular expression path');\n    } else {\n      path = this.originalPath\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional, offset) {\n            slash = slash || '';\n            value = params[key];\n            isValueDefined = typeof value !== 'undefined';\n\n            if (optional && !isValueDefined) {\n              value = '';\n            } else if (!isValueDefined) {\n              isMissingParams = true;\n              return;\n            }\n\n            value = _.isFunction(value) ? value.call(params) : value;\n            var escapedValue = _.map(String(value).split('/'), function (segment) {\n              return encodeURIComponent(segment);\n            }).join('/');\n            return slash + escapedValue\n          }\n        )\n        .replace(\n          /\\*/g,\n          function (match) {\n            if (typeof params[wildCardCount] === 'undefined') {\n              throw new Error(\n                'You are trying to access a wild card parameter at index ' +\n                wildCardCount +\n                ' but the value of params at that index is undefined');\n            }\n\n            var paramValue = String(params[wildCardCount++]);\n            return _.map(paramValue.split('/'), function (segment) {\n              return encodeURIComponent(segment);\n            }).join('/');\n          }\n        );\n\n      if (_.isObject(query)) {\n        query = _.map(_.pairs(query), function (queryPart) {\n          return queryPart[0] + '=' + encodeURIComponent(queryPart[1]);\n        }).join('&');\n      }\n\n      if (query && query.length)\n        path = path + '?' + query;\n\n      if (hash) {\n        hash = encodeURI(hash.replace('#', ''));\n        path = query ?\n          path + '#' + hash : path + '/#' + hash;\n      }\n    }\n\n    // Because of optional possibly empty segments we normalize path here\n    path = path.replace(/\\/+/g, '/'); // Multiple / -> one /\n    path = path.replace(/^(.+)\\/$/g, '$1'); // Removal of trailing /\n\n    return isMissingParams ? null : path;\n  },\n\n  path: function (params, options) {\n    return this.resolve(params, options);\n  },\n\n  url: function (params, options) {\n    var path = this.path(params, options);\n    if (path) {\n      if (path.charAt(0) === '/')\n        path = path.slice(1, path.length);\n      return Meteor.absoluteUrl() + path;\n    } else {\n      return null;\n    }\n  },\n\n  findController: function (path, options) {\n    var self = this;\n    var handler;\n    var controllerClass;\n    var controller;\n    var action;\n    var routeName;\n\n    var resolveValue = Utils.resolveValue;\n    var toArray = Utils.toArray;\n\n    var resolveController = function (name) {\n      var controller = resolveValue(name);\n      if (typeof controller === 'undefined') {\n        throw new Error(\n          'controller \"' + name + '\" is not defined');\n      }\n\n      return controller;\n    };\n\n    // controller option is a string specifying the name\n    // of a controller somewhere\n    if (_.isString(this.controller))\n      controller = resolveController(this.controller);\n    else if (_.isFunction(this.controller))\n      controller = this.controller;\n    else if (this.name)\n      controller = resolveValue(Router.convertRouteControllerName(this.name + 'Controller'));\n\n    if (!controller)\n      controller = RouteController;\n\n    return controller;\n  },\n\n  newController: function (path, options) {\n    var C = this.findController(path, options);\n\n    options = _.extend({}, options, {\n      path: path,\n      params: this.params(path),\n      where: this.where,\n      action: this.action\n    });\n\n    return new C(this.router, this, options);\n  },\n\n  getController: function (path, options) {\n    return this.newController(path, options);\n  }.deprecate({where: 'Route', name: 'getController', instead: 'newController'})\n};\n","RouteController = function (router, route, options) {\n  var self = this;\n\n  if (!(router instanceof IronRouter))\n    throw new Error('RouteController requires a router');\n\n  if (!(route instanceof Route))\n    throw new Error('RouteController requires a route');\n\n  options = this.options = options || {};\n\n  this.router = router;\n  this.route = route;\n\n  this.path = options.path || '';\n  this.params = options.params || [];\n  this.where = options.where || 'client';\n  this.action = options.action || this.action;\n\n  Utils.rewriteLegacyHooks(this.options);\n  Utils.rewriteLegacyHooks(this);\n};\n\nRouteController.prototype = {\n  constructor: RouteController,\n\n  /**\n   * Returns the value of a property, searching for the property in this lookup\n   * order:\n   *\n   *   1. RouteController options\n   *   2. RouteController prototype\n   *   3. Route options\n   *   4. Router options\n   */\n  lookupProperty: function (key) {\n    var value;\n\n    if (!_.isString(key))\n      throw new Error('key must be a string');\n\n    // 1. RouteController options\n    if (typeof (value = this.options[key]) !== 'undefined')\n      return value;\n\n    // 2. RouteController instance\n    if (typeof (value = this[key]) !== 'undefined')\n      return value;\n\n    var opts;\n    \n    // 3. Route options\n    opts = this.route.options;\n    if (opts && typeof (value = opts[key]) !== 'undefined')\n      return value;\n\n    // 4. Router options\n    opts = this.router.options;\n    if (opts && typeof (value = opts[key]) !== 'undefined')\n      return value;\n\n    // 5. Oops couldn't find property\n    return undefined;\n  },\n\n  runHooks: function (hookName, more, cb) {\n    var self = this;\n    var ctor = this.constructor;\n\n    if (!_.isString(hookName))\n      throw new Error('hookName must be a string');\n\n    if (more && !_.isArray(more))\n      throw new Error('more must be an array of functions');\n\n    var isPaused = false;\n\n    var lookupHook = function (nameOrFn) {\n      var fn = nameOrFn;\n\n      // if we already have a func just return it\n      if (_.isFunction(fn))\n        return fn;\n\n      // look up one of the out-of-box hooks like\n      // 'loaded or 'dataNotFound' if the nameOrFn is a\n      // string\n      if (_.isString(fn)) {\n        if (_.isFunction(Router.hooks[fn]))\n          return Router.hooks[fn];\n      }\n\n      // we couldn't find it so throw an error\n      throw new Error(\"No hook found named: \", nameOrFn);\n    }; \n\n    // concatenate together hook arrays from the inheritance\n    // heirarchy, starting at the top parent down to the child.\n    var collectInheritedHooks = function (ctor) {\n      var hooks = [];\n\n      if (ctor.__super__)\n        hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor));\n      \n      return Utils.hasOwnProperty(ctor.prototype, hookName) ?\n        hooks.concat(ctor.prototype[hookName]) : hooks;\n    };\n\n\n    // get a list of hooks to run in the following order:\n    // 1. RouteController option hooks\n    // 2. RouteController proto hooks (including inherited super to child)\n    // 3. RouteController object hooks\n    // 4. Router global hooks\n    // 5. Route option hooks\n    // 6. more\n\n    var toArray = Utils.toArray;\n    var routerHooks = this.router.getHooks(hookName, this.route.name);\n\n    var opts;\n    opts = this.route.options;\n    var routeOptionHooks = toArray(opts && opts[hookName]);\n\n    opts = this.options;\n    var optionHooks = toArray(opts && opts[hookName]);\n\n    var protoHooks = collectInheritedHooks(this.constructor);\n\n    var objectHooks;\n    // don't accidentally grab the prototype hooks!\n    // this makes sure the hook is on the object itself\n    // not on its constructor's prototype object.\n    if (_.has(this, hookName))\n      objectHooks = toArray(this[hookName])\n    else\n      objectHooks = [];\n\n    var allHooks = optionHooks\n      .concat(protoHooks)\n      .concat(objectHooks)\n      .concat(routeOptionHooks)\n      .concat(routerHooks)\n      .concat(more);\n\n    var isPaused = false;\n    var pauseFn = function () {\n      isPaused = true;\n    };\n\n    for (var i = 0, hook; hook = allHooks[i]; i++) {\n      var hookFn = lookupHook(hook);\n\n      if (!isPaused && !this.isStopped)\n        hookFn.call(self, pauseFn, i);\n    }\n\n    cb && cb.call(self, isPaused);\n    return isPaused;\n  },\n\n  action: function () {\n    throw new Error('not implemented');\n  },\n\n  stop: function (cb) {\n    return this._stopController(cb);\n  },\n\n  _stopController: function (cb) {\n    var self = this;\n\n    if (this.isStopped)\n      return;\n\n    self.isRunning = false;\n    self.runHooks('onStop');\n    self.isStopped = true;\n    cb && cb.call(self);\n  },\n\n  _run: function () {\n    throw new Error('not implemented');\n  }\n};\n\n_.extend(RouteController, {\n  /**\n   * Inherit from RouteController\n   *\n   * @param {Object} definition Prototype properties for inherited class.\n   */\n\n  extend: function (definition) {\n    Utils.rewriteLegacyHooks(definition);\n\n    return Utils.extend(this, definition, function (definition) {\n      var klass = this;\n\n      \n      /*\n        Allow calling a class method from javascript, directly in the subclass\n        definition.\n\n        Instead of this:\n          MyController = RouteController.extend({...});\n          MyController.before(function () {});\n\n        You can do:\n          MyController = RouteController.extend({\n            before: function () {}\n          });\n       \n        And in Coffeescript you can do:\n         MyController extends RouteController\n           @before function () {}\n       */\n    });\n  }\n});\n","IronRouter = function (options) {\n  var self = this;\n\n  this.configure(options);\n\n  /**\n   * The routes array which doubles as a named route index by adding\n   * properties to the array.\n   *\n   * @api public\n   */\n  this.routes = [];\n\n  /**\n   * Default name conversions for controller\n   * and template lookup.\n   */\n  this._nameConverters = {};\n  this.setNameConverter('Template', 'none');\n  this.setNameConverter('RouteController', 'upperCamelCase');\n\n  this._globalHooks = {};\n  _.each(IronRouter.HOOK_TYPES, function (type) {\n    self._globalHooks[type] = [];\n\n    // example:\n    //  self.onRun = function (hook, options) {\n    //    return self.addHook('onRun', hook, options);\n    //  };\n    self[type] = function (hook, options) {\n      return self.addHook(type, hook, options);\n    };\n  });\n\n  _.each(IronRouter.LEGACY_HOOK_TYPES, function (type, legacyType) {\n    self[legacyType] = function () {\n      Utils.notifyDeprecated({\n        where: 'Router',\n        name: legacyType,\n        instead: type\n      });\n\n      return self[type].apply(this, arguments);\n    }\n  });\n};\n\nIronRouter.HOOK_TYPES = [\n  'onRun',\n  'onData',\n  'onBeforeAction',\n  'onAfterAction',\n  'onStop',\n\n  // not technically a hook but we'll use it\n  // in a similar way. This will cause waitOn\n  // to be added as a method to the Router and then\n  // it can be selectively applied to specific routes\n  'waitOn'\n];\n\nIronRouter.LEGACY_HOOK_TYPES = {\n  'load': 'onRun',\n  'before': 'onBeforeAction',\n  'after': 'onAfterAction',\n  'unload': 'onStop'\n};\n\nIronRouter.prototype = {\n  constructor: IronRouter,\n\n  /**\n   * Configure instance with options. This can be called at any time. If the\n   * instance options object hasn't been created yet it is created here.\n   *\n   * @param {Object} options\n   * @return {IronRouter}\n   * @api public\n   */\n\n  configure: function (options) {\n    var self = this;\n\n    options = options || {};\n    this.options = this.options || {};\n    _.extend(this.options, options);\n\n    // e.g. before: fn OR before: [fn1, fn2]\n    _.each(IronRouter.HOOK_TYPES, function(type) {\n      if (self.options[type]) {\n        _.each(Utils.toArray(self.options[type]), function(hook) {\n          self.addHook(type, hook);\n        });\n\n        delete self.options[type];\n      }\n    });\n    \n    _.each(IronRouter.LEGACY_HOOK_TYPES, function(type, legacyType) {\n      if (self.options[legacyType]) {\n        // XXX: warning?\n        _.each(Utils.toArray(self.options[legacyType]), function(hook) {\n          self.addHook(type, hook);\n        });\n\n        delete self.options[legacyType];\n      }\n    });\n\n    if (options.templateNameConverter)\n      this.setNameConverter('Template', options.templateNameConverter);\n\n    if (options.routeControllerNameConverter)\n      this.setNameConverter('RouteController', options.routeControllerNameConverter);\n\n    return this;\n  },\n\n  convertTemplateName: function (input) {\n    var converter = this._nameConverters['Template'];\n    if (!converter)\n      throw new Error('No name converter found for Template');\n    return converter(input);\n  },\n\n  convertRouteControllerName: function (input) {\n    var converter = this._nameConverters['RouteController'];\n    if (!converter)\n      throw new Error('No name converter found for RouteController');\n    return converter(input);\n  },\n\n  setNameConverter: function (key, stringOrFunc) {\n    var converter;\n\n    if (_.isFunction(stringOrFunc))\n      converter = stringOrFunc;\n\n    if (_.isString(stringOrFunc))\n      converter = Utils.StringConverters[stringOrFunc];\n\n    if (!converter) {\n      throw new Error('No converter found named: ' + stringOrFunc);\n    }\n\n    this._nameConverters[key] = converter;\n    return this;\n  },\n\n  /**\n   *\n   * Add a hook to all routes. The hooks will apply to all routes,\n   * unless you name routes to include or exclude via `only` and `except` options\n   *\n   * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n   * @param {Object} [options] Options to controll the hooks [optional]\n   * @param {Function} [hook] Callback to run\n   * @return {IronRouter}\n   * @api public\n   *\n   */\n\n  addHook: function(type, hook, options) {\n    options = options || {}\n\n    if (options.only)\n      options.only = Utils.toArray(options.only);\n    if (options.except)\n      options.except = Utils.toArray(options.except);\n\n    this._globalHooks[type].push({options: options, hook: hook});\n\n    return this;\n  },\n\n  /**\n   *\n   * Fetch the list of global hooks that apply to the given route name.\n   * Hooks are defined by the .addHook() function above.\n   *\n   * @param {String} [type] one of IronRouter.HOOK_TYPES\n   * @param {String} [name] the name of the route we are interested in\n   * @return {[Function]} [hooks] an array of hooks to run\n   * @api public\n   *\n   */\n\n  getHooks: function(type, name) {\n    var hooks = [];\n\n    _.each(this._globalHooks[type], function(hook) {\n      var options = hook.options;\n\n      if (options.except && _.include(options.except, name))\n        return;\n\n      if (options.only && ! _.include(options.only, name))\n        return;\n\n      hooks.push(hook.hook);\n    });\n\n    return hooks;\n  },\n\n\n  /**\n   * Convenience function to define a bunch of routes at once. In the future we\n   * might call the callback with a custom dsl.\n   *\n   * Example:\n   *  Router.map(function () {\n   *    this.route('posts');\n   *  });\n   *\n   *  @param {Function} cb\n   *  @return {IronRouter}\n   *  @api public\n   */\n\n  map: function (cb) {\n    Utils.assert(_.isFunction(cb),\n           'map requires a function as the first parameter');\n    cb.call(this);\n    return this;\n  },\n\n  /**\n   * Define a new route. You must name the route, but as a second parameter you\n   * can either provide an object of options or a Route instance.\n   *\n   * @param {String} name The name of the route\n   * @param {Object} [options] Options to pass along to the route\n   * @return {Route}\n   * @api public\n   */\n\n  route: function (name, options) {\n    var route;\n\n    Utils.assert(_.isString(name), 'name is a required parameter');\n\n    if (options instanceof Route)\n      route = options;\n    else\n      route = new Route(this, name, options);\n\n    this.routes[name] = route;\n    this.routes.push(route);\n    return route;\n  },\n\n  path: function (routeName, params, options) {\n    var route = this.routes[routeName];\n    Utils.warn(route,\n     'You called Router.path for a route named ' + routeName + ' but that route doesn\\'t seem to exist. Are you sure you created it?');\n    return route && route.path(params, options);\n  },\n\n  url: function (routeName, params, options) {\n    var route = this.routes[routeName];\n    Utils.warn(route,\n      'You called Router.url for a route named \"' + routeName + '\" but that route doesn\\'t seem to exist. Are you sure you created it?');\n    return route && route.url(params, options);\n  },\n\n  match: function (path) {\n    return _.find(this.routes, function(r) { return r.test(path); });\n  },\n    \n  dispatch: function (path, options, cb) {\n    var route = this.match(path);\n    \n    if (! route)\n      return this.onRouteNotFound(path, options);\n    \n    if (route.where !== (Meteor.isClient ? 'client' : 'server'))\n      return this.onUnhandled(path, options);\n    \n    var controller = route.newController(path, options);\n    this.run(controller, cb);\n  },\n\n  run: function (controller, cb) {\n    var self = this;\n    var where = Meteor.isClient ? 'client' : 'server';\n\n    Utils.assert(controller, 'run requires a controller');\n\n    // one last check to see if we should handle the route here\n    if (controller.where != where) {\n      self.onUnhandled(controller.path, controller.options);\n      return;\n    }\n\n    var run = function () {\n      self._currentController = controller;\n      // set the location\n      cb && cb(controller);\n      self._currentController._run();\n    };\n\n    // if we already have a current controller let's stop it and then\n    // run the new one once the old controller is stopped. this will add\n    // the run function as an onInvalidate callback to the controller's\n    // computation. Otherwse, just run the new controller.\n    if (this._currentController)\n      this._currentController._stopController(run);\n    else\n      run();\n  },\n\n  onUnhandled: function (path, options) {\n    throw new Error('onUnhandled not implemented');\n  },\n\n  onRouteNotFound: function (path, options) {\n    throw new Error('Oh no! No route found for path: \"' + path + '\"');\n  }\n};\n","var dep = new Deps.Dependency;\n// XXX: we have to store the state internally (rather than just calling out\n// to window.location) due to an android 2.3 bug. See:\n//   https://github.com/EventedMind/iron-router/issues/350\nvar currentState = {\n  path: location.pathname + location.search + location.hash,\n  // we set title to null because that can be triggered immediately by a \"noop\"\n  // popstate that happens on load -- if it's already null, nothing's changed.\n  title: null\n};\n\nfunction onpopstate (e) {\n  setState(e.originalEvent.state, null, location.pathname + location.search + location.hash);\n}\n\nIronLocation = {};\n\nIronLocation.origin = function () {\n  return location.protocol + '//' + location.host;\n};\n\nIronLocation.isSameOrigin = function (href) {\n  var origin = IronLocation.origin();\n  return href.indexOf(origin) === 0;\n};\n\nIronLocation.get = function () {\n  dep.depend();\n  return currentState;\n};\n\nIronLocation.path = function () {\n  dep.depend();\n  return currentState.path;\n};\n\nIronLocation.set = function (url, options) {\n  options = options || {};\n\n  var state = options.state || {};\n\n  if (/^http/.test(url))\n    href = url;\n  else {\n    if (url.charAt(0) !== '/')\n      url = '/' + url;\n    href = IronLocation.origin() + url;\n  }\n\n  if (!IronLocation.isSameOrigin(href))\n    window.location = href;\n  else if (options.where === 'server')\n    window.location = href;\n  else if (options.replaceState)\n    IronLocation.replaceState(state, options.title, url, options.skipReactive);\n  else\n    IronLocation.pushState(state, options.title, url, options.skipReactive);\n};\n\n// store the state for later access\nsetState = function(newState, title, url, skipReactive) {\n  newState = _.extend({}, newState);\n  newState.path = url;\n  newState.title = title;\n\n  if (!skipReactive && ! EJSON.equals(currentState, newState))\n    dep.changed();\n\n  currentState = newState;\n}\n\nIronLocation.pushState = function (state, title, url, skipReactive) {\n  setState(state, title, url, skipReactive);\n\n  if (history.pushState)\n    history.pushState(state, title, url);\n  else\n    window.location = url;\n};\n\nIronLocation.replaceState = function (state, title, url, skipReactive) {\n  // allow just the state or title to be set\n  if (arguments.length < 2)\n    title = currentState.title;\n  if (arguments.length < 3)\n    url = currentState.path;\n\n  setState(state, title, url, skipReactive);\n\n  if (history.replaceState)\n    history.replaceState(state, title, url);\n  else\n    window.location = url;\n};\n\nIronLocation.bindEvents = function(){\n  $(window).on('popstate.iron-router', onpopstate);\n};\n\nIronLocation.unbindEvents = function(){\n  $(window).off('popstate.iron-router');\n};\n\nIronLocation.start = function () {\n  if (this.isStarted)\n    return;\n\n  IronLocation.bindEvents();\n  this.isStarted = true;\n  // store the fact that this is the first route we hit.\n  // this serves two purposes\n  //   1. We can tell when we've reached an unhandled route and need to show a\n  //      404 (rather than bailing out to let the server handle it)\n  //   2. Users can look at the state to tell if the history.back() will stay\n  //      inside the app (this is important for mobile apps).\n  if (history.replaceState)\n    history.replaceState({initial: true}, null, location.pathname + location.search + location.hash);\n};\n\nIronLocation.stop = function () {\n  IronLocation.unbindEvents();\n  this.isStarted = false;\n};\n","/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\nvar bindData = function (value, thisArg) {\n  return function () {\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;\n  };\n};\n\n/*****************************************************************************/\n/* IronRouter */\n/*****************************************************************************/\nIronRouter = Utils.extend(IronRouter, {\n  constructor: function (options) {\n    var self = this;\n\n    IronRouter.__super__.constructor.apply(this, arguments);\n    self.options.linkSelector = self.options.linkSelector || 'a[href]';\n\n    options = options || {};\n    \n    this.isRendered = false;\n\n    /**\n     * The current RouteController instance. This is set anytime a new route is\n     * dispatched. It's a reactive variable which you can get by calling\n     * Router.current();\n     *\n     * @api private\n     */\n    this._currentController = null;\n\n    /**\n     * Dependency to for this._currentController\n     *\n     * @api private\n     */\n    this._controllerDep = new Deps.Dependency;\n\n    /**\n      * Did the URL we are looking at come from a hot-code-reload \n      *  (and thus should we treat is as not new?)\n      * \n      * @api private\n      */\n    this._hasJustReloaded = false;\n\n    Meteor.startup(function () {\n      Meteor.defer(function () {\n        if (self.options.autoRender !== false)\n          self.autoRender();\n        if (self.options.autoStart !== false)\n          self.start();\n      });\n    });\n\n    // manages dynamic rendering\n    // XXX we'll keep the same router api for now and clean it up to be more\n    // sensible on the next pass (to more closely mimic the new Iron.Layout api\n    // which is a lot nicer).\n    this._layout = new Iron.Layout({template: this.options.layoutTemplate});\n\n    /*\n    // proxy these methods to the underlying ui manager object\n    _.each([\n      'layout',\n      'setRegion',\n      'clearRegion',\n      'getData',\n      'setData'\n    ], function (uiApiMethod) {\n      self[uiApiMethod] = function () {\n        if (!self._ui)\n          throw new Error(\"No uiManager is configured on the Router\");\n        return self._ui[uiApiMethod].apply(self._ui, arguments);\n      };\n    });\n    */\n  },\n\n  layout: function (template, options) {\n    var result = this._layout.template(template);\n\n    // check whether options has a data property\n    if (options && (_.has(options, 'data')))\n      this._layout.data(bindData(options.data, this));\n\n    return result;\n  },\n\n  setRegion: function (region, template) {\n    if (arguments.length === 1) {\n      template = region;\n      region = null;\n    }\n\n    this._layout.render(template, {to: region});\n    return this;\n  },\n\n  clearRegion: function (region) {\n    this._layout.clear(region);\n    return this;\n  },\n\n  /**\n   * Reactive accessor for the current RouteController instance. You can also\n   * get a nonreactive value by specifiying {reactive: false} as an option.\n   *\n   * @param {Object} [opts] configuration options\n   * @param {Boolean} [opts.reactive] Set to false to enable a non-reactive read.\n   * @return {RouteController}\n   * @api public\n   */\n\n  current: function (opts) {\n    if (opts && opts.reactive === false)\n      return this._currentController;\n    else {\n      this._controllerDep.depend();\n      return this._currentController;\n    }\n  },\n\n  clearUnusedRegions: function (usedYields) {\n    var self = this;\n\n    //XXX clean this up in next major release\n    var allYields = _.keys(this._layout._regions);\n\n    usedYields = _.filter(usedYields, function (val) {\n      return !!val;\n    });\n\n    var unusedYields = _.difference(allYields, usedYields);\n\n    _.each(unusedYields, function (key) {\n      self.clearRegion(key);\n    });\n  },\n\n  run: function (controller, cb) {\n    IronRouter.__super__.run.apply(this, arguments);\n\n    if (controller == this._currentController) {\n      this._controllerDep.changed();\n    }\n  },\n\n  /**\n   * Wrapper around Location.go that accepts a routeName or a path as the first\n   * parameter. This method can accept client and server side routes.\n   *\n   * Examples:\n   *\n   *  1. Router.go('/posts', {state: 'true'});\n   *  2. Router.go('postIndex', [param1, param2], {state});\n   *\n   * @param {String} routeNameOrPath\n   * @param {Array|Object} [params]\n   * @param {Object} [state]\n   * @param {Boolean} [replaceState]\n   * @api public\n   */\n\n  go: function (routeNameOrPath, params, options) {\n    var self = this;\n    var isPathRe = /^\\/|http/\n    var route;\n    var path;\n    var onComplete;\n    var controller;\n    var done;\n    \n    // after the dispatch is complete, set the IronLocation\n    // path and state which will update the browser's url.\n    done = function() {\n      options = options || {};\n      self._location.set(path, {\n        replaceState: options.replaceState,\n        state: options.state,\n        skipReactive: true\n      });\n    };\n\n    if (isPathRe.test(routeNameOrPath)) {\n      path = routeNameOrPath;\n      options = params;\n      \n      // if the path hasn't changed (at all), we are going to do nothing here\n      if (path === self._location.path()) {\n        if (self.options.debug)\n          console.log(\"You've navigated to the same path that you are currently at. Doing nothing\");\n        return;\n      }\n      \n      // issue here is in the dispatch process we might want to\n      // make a server request so therefore not call this method yet, so\n      // we need to push the state only after we've decided it's a client\n      // request, otherwise let the browser handle it and send off to the\n      // server\n      self.dispatch(path, options, done);\n    } else {\n      route = self.routes[routeNameOrPath];\n      Utils.assert(route, 'No route found named ' + routeNameOrPath);\n      path = route.path(params, options);\n      controller = route.newController(path, options);\n      self.run(controller, done);\n    }\n  },\n\n  render: function () {\n    this.isRendered = true;\n\n    // return a UI component for the layout.\n    return this._layout.create();\n  },\n\n  autoRender: function () {\n    this.isRendered = true;\n\n    this._layout.insert({\n      // insert into the document body element\n      el: document.body,\n      \n      // come back and make this body at some point\n      parentComponent: null\n    });\n  },\n\n  bindEvents: function () {\n    $(document).on('click.ironRouter', this.options.linkSelector, _.bind(this.onClick, this));\n  },\n\n  unbindEvents: function () {\n    $(document).off('click.ironRouter', this.options.linkSelector);\n  },\n\n  /**\n   * Start listening to click events and set up a Deps.autorun for location\n   * changes. If already started the method just returns.\n   *\n   * @api public\n   */\n\n  start: function () {\n    var self = this;\n\n    if (self.isStarted) return;\n\n    self.isStarted = true;\n    \n    self._location = self.options.location || IronLocation;\n    self._location.start();\n    \n    self.bindEvents();\n\n    Deps.autorun(function (c) {\n      var location;\n      self._locationComputation = c;\n      self.dispatch(self._location.path(), {state: history.state});\n    });\n  },\n\n  /**\n   * Remove click event listener and stop listening for location changes.\n   *\n   * @api public\n   */\n\n  stop: function () {\n    this.isStarted = false;\n\n    this.unbindEvents();\n    this._location.stop();\n\n    if (this._locationComputation)\n      this._locationComputation.stop();\n  },\n\n  /**\n   * If we don't handle a link but the server does, bail to the server\n   *\n   * @api public\n   */\n  onUnhandled: function (path, options) {\n    window.location = path;\n  },\n  \n  /**\n   * if we don't handle a link, _and_ the  server doesn't handle it,\n   * do one of two things:\n   *   a) if this is the initial route, then it can't be a static asset, so \n   *      show notFound or throw an error\n   *   b) otherwise, let the server have a go at it, we may end up coming back.\n   *\n   * @api public\n   */\n  onRouteNotFound: function (path, options) {\n    if (this._location.path() !== path) {\n      window.location = path;\n    } else if (this.options.notFoundTemplate) {\n      var notFoundRoute = new Route(this, '__notfound__', _.extend(options || {}, {path: path}));\n      this.run(new RouteController(this, notFoundRoute, {\n        layoutTemplate: this.options.layoutTemplate,\n        template: this.options.notFoundTemplate\n      }));\n    } else {\n      throw new Error('Oh no! No route found for path: \"' + path + '\"');\n    }\n  },\n  \n  onClick: function(e) {\n    var el = e.currentTarget;\n    var which = _.isUndefined(e.which) ? e.button : e.which;\n    var href = el.href;\n    var path = el.pathname + el.search + el.hash;\n\n    // ie9 omits the leading slash in pathname - so patch up if it's missing\n    path = path.replace(/(^\\/?)/,\"/\");\n\n    // we only want to handle clicks on links which:\n    // - haven't been cancelled already\n    if (e.isDefaultPrevented())\n      return;\n\n    //  - are with the left mouse button with no meta key pressed\n    if (which !== 1)\n      return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) \n      return;\n\n    // - aren't in a new window\n    if (el.target)\n      return;\n\n    // - aren't external to the app\n    if (!IronLocation.isSameOrigin(href)) \n      return;\n\n    // note that we _do_ handle links which point to the current URL\n    // and links which only change the hash.\n    e.preventDefault();\n    this.go(path);\n  }\n});\n\n/**\n * The main Router instance that clients will deal with\n *\n * @api public\n * @exports Router\n */\n\nRouter = new IronRouter;\n\nif (Meteor._reload) {\n  // just register the fact that a migration _has_ happened\n  Meteor._reload.onMigrate('iron-router', function() { return [true, true]});\n  \n  // then when we come back up, check if it it's set\n  var data = Meteor._reload.migrationData('iron-router');\n  Router._hasJustReloaded = data;\n}\n","/*****************************************************************************/\n/* Imports */\n/*****************************************************************************/\nvar assert = Iron.utils.assert;\n\n/*****************************************************************************/\n/* Private */\n/*****************************************************************************/\n\n/**\n * Returns an object of computation ids starting with\n * the current computation and including all ancestor\n * computations. The data structure is an object\n * so we can index by id and do quick checks.\n */\nvar parentComputations = function () {\n  var list = {};\n  var c = Deps.currentComputation;\n\n  while (c) {\n    list[String(c._id)] = true;\n    c = c._parent;\n  }\n\n  return list;\n};\n\n/**\n * Check whether the user has called ready() and then called wait(). This\n * can cause a condition that can be simplified to this:\n *\n * dep = new Deps.Dependency;\n *\n * Deps.autorun(function () {\n *   dep.depend();\n *   dep.changed();\n * });\n */\nvar assertNoInvalidationLoop = function (dependency) {\n  var parentComps = parentComputations();\n  var depCompIds = Object.keys(dependency._dependentsById);\n\n  depCompIds.forEach(function (id) {\n    assert(!parentComps[id], \"\\n\\n\\\nYou called wait() after calling ready() inside the same computation tree.\\\n\\n\\n\\\nYou can fix this problem in two possible ways:\\n\\n\\\n1) Put all of your wait() calls before any ready() calls.\\n\\\n2) Put your ready() call in its own computation with Deps.autorun.\"\n    );\n  });\n};\n\n\n/*****************************************************************************/\n/* WaitList */\n/*****************************************************************************/\n/**\n * A WaitList tracks a list of reactive functions, each in its own computation.\n * The list is ready() when all of the functions return true. This list is not\n * ready (i.e. this.ready() === false) if at least one function returns false.\n *\n * You add functions by calling the wait(fn) method. Each function is run its\n * own computation. The ready() method is a reactive method but only calls the\n * deps changed function if the overall state of the list changes from true to\n * false or from false to true.\n */\nWaitList = function () {\n  this._readyDep = new Deps.Dependency;\n  this._comps = [];\n  this._notReadyCount = 0;\n};\n\n/**\n * Pass a function that returns true or false.\n */\nWaitList.prototype.wait = function (fn) {\n  var self = this;\n\n  var activeComp = Deps.currentComputation;\n\n  assertNoInvalidationLoop(self._readyDep);\n\n  // break with parent computation and grab the new comp\n  Deps.nonreactive(function () {\n\n    // store the cached result so we can see if it's different from one run to\n    // the next.\n    var cachedResult = null;\n\n    // create a computation for this handle\n    var comp = Deps.autorun(function (c) {\n      // let's get the new result coerced into a true or false value.\n      var result = !!fn();\n\n      var oldNotReadyCount = self._notReadyCount;\n\n      // if it's the first run and we're false then inc\n      if (c.firstRun && !result)\n        self._notReadyCount++;\n      else if (cachedResult !== null && result !== cachedResult && result === true)\n        self._notReadyCount--;\n      else if (cachedResult !== null && result !== cachedResult && result === false)\n        self._notReadyCount++;\n\n      cachedResult = result;\n\n      if (oldNotReadyCount === 0 && self._notReadyCount > 0)\n        self._readyDep.changed();\n      else if (oldNotReadyCount > 0 && self._notReadyCount === 0)\n        self._readyDep.changed();\n    });\n\n    self._comps.push(comp);\n\n    if (activeComp) {\n      activeComp.onInvalidate(function () {\n        // keep the old computation and notReadyCount the same for one\n        // flush cycle so that we don't end up in an intermediate state\n        // where list.ready() is not correct.\n\n        // keep the state the same until the flush cycle is complete\n        Deps.afterFlush(function () {\n          // stop the computation\n          comp.stop();\n\n          // remove the computation from the list\n          self._comps.splice(_.indexOf(self._comps, comp), 1);\n\n          if (cachedResult === false) {\n            self._notReadyCount--;\n\n            if (self._notReadyCount === 0)\n              self._readyDep.changed();\n          }\n        });\n      });\n    }\n  });\n};\n\nWaitList.prototype.ready = function () {\n  this._readyDep.depend();\n  return this._notReadyCount === 0;\n};\n\nWaitList.prototype.stop = function () {\n  _.each(this._comps, function (c) { c.stop(); });\n  this._comps = [];\n};\n","Router.hooks = {\n  dataNotFound: function (pause) {\n    var tmpl;\n\n    if (!this.ready())\n      return;\n    \n    if (!this._hasData())\n      return;\n\n    var data = this.data();\n\n    if (data === false || data === null || typeof data === 'undefined') {\n      tmpl = this.lookupProperty('notFoundTemplate');\n\n      if (tmpl) {\n        this.render(tmpl);\n        this.renderRegions();\n        pause();\n      }\n    }\n  },\n\n  loading: function (pause) {\n    var self = this;\n    var tmpl;\n\n    if (!this.ready()) {\n      tmpl = this.lookupProperty('loadingTemplate');\n\n      if (tmpl) {\n        this.render(tmpl);\n        this.renderRegions();\n        pause();\n      }\n    }\n  }\n};\n","var isLogging = false;\nvar log = function (msg) {\n  if (!isLogging)\n    return;\n  console.log('%c<RouteController> ' + msg, 'color: purple; font-size: 1.3em; font-weight: bold;');\n};\n\nvar bindData = function (value, thisArg) {\n  return function () {\n    return (typeof value === 'function') ? value.apply(thisArg, arguments) : value;\n  };\n};\n\nRouteController = Utils.extend(RouteController, {\n  constructor: function () {\n    var self = this;\n\n    RouteController.__super__.constructor.apply(this, arguments);\n\n    this._waitList = new WaitList;\n\n    //XXX putting this back so people can access data by calling\n    //this.data().\n\n    var data = this.lookupProperty('data');\n\n    this._hasData = function () { return typeof data !== 'undefined'; };\n    this.data = bindData(data, this);\n\n    // proxy these methods to the router\n    _.each([\n      'layout',\n      'setRegion',\n      'clearRegion'\n    ], function (routerApiMethod) {\n      self[routerApiMethod] = function () {\n        if (!self.router)\n          throw new Error(\"No router defined on RouteController\");\n        return self.router[routerApiMethod].apply(self.router, arguments);\n      };\n    });\n  },\n\n  setLayout: function () {\n    return this.layout.apply(this, arguments);\n  },\n\n  ready: function () {\n    return this._waitList.ready();\n  },\n\n  /**\n   * Stop running this controller and redirect to a new path. Same parameters as\n   * those of Router.go.\n   * @api public\n   */\n\n  redirect: function (/* args */) {\n    return Router.go.apply(Router, arguments);\n  },\n\n  subscribe: function (/* same as Meteor.subscribe */) {\n    var self = this;\n    var handle = Meteor.subscribe.apply(this, arguments);\n\n    return _.extend(handle, {\n      wait: function () {\n        self.wait(this);\n      }\n    });\n  },\n\n  lookupLayoutTemplate: function () {\n    return this.lookupProperty('layoutTemplate');\n  },\n\n  lookupTemplate: function () {\n    return this.lookupProperty('template')\n      || Router.convertTemplateName(this.route.name);\n  },\n\n  lookupRegionTemplates: function () {\n    var res;\n\n    if (res = this.lookupProperty('regionTemplates'))\n      return res;\n    else if (res = this.lookupProperty('yieldTemplates'))\n      return res;\n    else\n      return {};\n  },\n\n  /**\n   * Return an array of waitOn values in the folowing order (although, ordering\n   * shouldn't really matter for waitOn). The result may contain sub arrays like\n   * this:\n   *   [[fn1, fn2], [fn3, fn4]]\n   *\n   *   1. Router options\n   *   2. Route options\n   *   3. Controller options\n   *   4. Controller instance\n   */\n\n  lookupWaitOn: function () {\n    var toArray = Utils.toArray;\n\n    var fromRouterHook = toArray(this.router.getHooks('waitOn', this.route.name));\n    var fromRouterOptions = toArray(this.router.options.waitOn);\n    var fromRouteOptions = toArray(this.route.options.waitOn);\n    var fromMyOptions = toArray(this.options.waitOn);\n    var fromInstOptions = toArray(this.waitOn);\n\n    return fromRouterHook\n      .concat(fromRouterOptions)\n      .concat(fromRouteOptions)\n      .concat(fromMyOptions)\n      .concat(fromInstOptions);\n  },\n\n  /**\n   * Either specify a template to render or call with no arguments to render the\n   * RouteController's template plus all of the yieldTemplates.\n   * \n   * XXX can we have some hooks here? would be nice to give\n   * iron-transitioner a place to plug in. Maybe onSetRegion(fn)?\n   */\n\n  render: function (template, options) {\n    var to;\n    var template;\n    var layout;\n    var self = this;\n\n    if (arguments.length == 0) {\n      this.setRegion(this.lookupTemplate());\n      this.renderRegions();\n    } else {\n      options = options || {};\n      to = options.to;\n      this.setRegion(to, template);\n    }\n  },\n  \n  renderRegions: function() {\n    var self = this;\n    var regionTemplates = this.lookupRegionTemplates();\n    \n    _.each(regionTemplates, function (opts, tmpl) {\n      self.render(tmpl, opts)\n    });\n  },\n\n  /**\n   * Add an item to the waitlist.\n   */\n  wait: function (fn) {\n    var self = this;\n\n    if (!fn)\n      // it's possible fn is just undefined but we'll just return instead\n      // of throwing an error, to make it easier to call this function\n      // with waitOn which might not return anything.\n      return;\n\n    if (_.isArray(fn)) {\n      _.each(fn, function eachWait (fnOrHandle) {\n        self.wait(fnOrHandle);\n      });\n    } else if (fn.ready) {\n      this._waitList.wait(function () { return fn.ready(); });\n    } else {\n      this._waitList.wait(fn);\n    }\n\n    return this;\n  },\n\n  action: function () {\n    this.render();\n  },\n\n  /**\n   * A private method that the Router can call into to\n   * stop the controller. The reason we need this is because we\n   * don't want users calling stop() in their hooks/action like they\n   * had done previously. We now want them to call pause(). stop() now\n   * completely stops the controller and tears down its computations. pause()\n   * just stopps running downstream functions (e.g. when you're running\n   * before/action/after functions. But if the outer computation causes the\n   * entire chain of functions to run again that's fine.\n   */\n  _stopController: function (cb) {\n    var self = this;\n\n    // noop if we're already stopped\n    if (this.isStopped)\n      return;\n\n    var onStop = function () {\n      RouteController.__super__._stopController.call(self, cb);\n    };\n\n    if (this._computation) {\n      this._computation.stop();\n      this._computation.onInvalidate(onStop);\n    } else {\n      onStop();\n    }\n  },\n\n  _run: function () {\n    var self = this;\n    var layout = self.router._layout;\n\n    // if we're already running, you can't call run again without\n    // calling stop first.\n    if (self.isRunning)\n      throw new Error(\"You called _run without first calling stop\");\n\n    self.isRunning = true;\n    self.isStopped = false;\n\n    var withNoStopsAllowed = function (fn, thisArg) {\n      return function () {\n        var oldStop = self.stop;\n\n        self.stop = function () {\n          if (typeof console !== 'undefined') {\n            console.warn(\"You called this.stop() inside a hook or your action function but you should use pause() now instead which is the first parameter to the hook function.\");\n            return;\n          }\n        };\n\n        try {\n          return fn.apply(thisArg || this, arguments);\n        } finally {\n          self.stop = oldStop;\n        }\n      };\n    };\n\n    Deps.autorun(withNoStopsAllowed(function (c) {\n      // outer most computation is just used to stop inner computations from one\n      // place. Is stopped when the route is routed away from, which includes\n      // if an route action redirects away.\n      self._computation = c;\n      \n      Deps.autorun(withNoStopsAllowed(function (onRunComp) {\n        if (!self.router._hasJustReloaded && c.firstRun && onRunComp.firstRun)\n          self.runHooks('onRun');\n        self.router._hasJustReloaded = false;\n      }));\n\n      Deps.autorun(function (c) {\n        // waitOn\n        var waitOnList = self.lookupWaitOn();\n        var waitOn = _.flatten(_.map(waitOnList, function (fnOrHandle) {\n          return _.isFunction(fnOrHandle) ? fnOrHandle.call(self) : fnOrHandle;\n        }));\n\n        log('waitOn');\n\n        self.wait(waitOn);\n      });\n\n      Deps.autorun(function (c) {\n        // if we're already in a renderig transaction we want to cancel the\n        // transaction. So the previous afterFlush callback should just be a\n        // noop, and the new afterflush callback should do what's required. But\n        // we need to keep a stack of these \n        self.router._layout.beginRendering(function onCompleteRenderingTransaction (usedRegions) {\n          if (self.isStopped)\n            return;\n          var allRegions = layout.regionKeys();\n          var unusedRegions = _.difference(allRegions, usedRegions);\n          _.each(unusedRegions, function (r) { layout.clear(r); });\n        });\n\n        // action\n        var action = _.isFunction(self.action) ? self.action : self[self.action];\n        Utils.assert(action,\n          \"You don't have an action named \\\"\" + self.action + \"\\\" defined on your RouteController\");\n\n        // Set layout to configured layoutTemplate\n        self.layout(self.lookupLayoutTemplate(), {\n          data: self.lookupProperty('data')\n        });\n        \n        self.runHooks('onBeforeAction', [], function (paused) {\n          if (self.isStopped)\n            return;\n\n          if (!paused) {\n            action.call(self);\n\n            if (!self.isStopped) {\n              self.runHooks('onAfterAction');\n            }\n          }\n        });\n      });\n    }));\n  }\n});\n","Router.helpers = {};\n\nvar getData = function (thisArg) {\n  return thisArg === window ? {} : thisArg;\n};\n\nvar processPathArgs = function (routeName, options) {\n  if (_.isObject(routeName)) {\n    options = routeName;\n    routeName = options.route;\n  }\n\n  var opts = options.hash || {};\n  var params = opts.params || _.omit(opts, 'hash', 'query');\n  var hash = opts.hash;\n  var query = opts.query;\n\n  // if called without opts, use the data context of the parent\n  if (_.isEmpty(opts))\n    params = getData(this);\n\n  return {\n    routeName: routeName,\n    params: params,\n    query: query,\n    hash: hash\n  };\n};\n\n_.extend(Router.helpers, {\n\n  /**\n   * Example Use:\n   *\n   *  {{pathFor 'items' params=this}}\n   *  {{pathFor 'items' id=5 query=\"view=all\" hash=\"somehash\"}}\n   *  {{pathFor route='items' id=5 query=\"view=all\" hash=\"somehash\"}}\n   */\n\n  pathFor: function (routeName, options) {\n    var args = processPathArgs.call(this, routeName, options);\n\n    return Router.path(args.routeName, args.params, {\n      query: args.query,\n      hash: args.hash\n    });\n  },\n\n  /**\n   * Same as pathFor but returns entire aboslute url.\n   *\n   */\n  urlFor: function (routeName, options) {\n    var args = processPathArgs.call(this, routeName, options);\n\n    return Router.url(args.routeName, args.params, {\n      query: args.query,\n      hash: args.hash\n    });\n  }\n});\n\n_.each(Router.helpers, function (helper, name) {\n  UI.registerHelper(name, helper);\n});\n","if (Package['cmather:iron-router']) {\n  throw new Error(\"\\n\\n\\\n    Sorry! The cmather:iron-{x} packages were migrated to the new package system with the wrong name, and you have duplicate copies.\\n\\\n    You can see which cmather:iron-{x} packages have been installed by using this command:\\n\\n\\\n    > meteor list\\n\\n\\\n    Can you remove any installed cmather:iron-{x} packages like this:\\\n    \\n\\n\\\n    > meteor remove cmather:iron-core\\n\\\n    > meteor remove cmather:iron-router\\n\\\n    > meteor remove cmather:iron-dynamic-template\\n\\\n    > meteor remove cmather:iron-dynamic-layout\\n\\\n    \\n\\\n    The new packages are named iron:{x}. For example:\\n\\n\\\n    > meteor add iron:router\\n\\n\\\n    Sorry for the hassle, but thank you!\\\n    \\n\\n\\\n  \");\n}\n"]}